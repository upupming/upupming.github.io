<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Google Kickstart 2021 Round B 题解"><meta name="keywords" content="algorithm"><meta name="author" content="upupming"><meta name="copyright" content="upupming"><title>Google Kickstart 2021 Round B 题解 | upupming 的博客</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.6.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="manifest" href="/manifest.json"><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#1B9EF3"><meta name="msapplication-TileColor" content="#1B9EF3"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#1B9EF3"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-2188191456032650',
  enable_page_level_ads: 'true'
});
</script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?295ad5c5a196e4964e20f74260711177";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-114899088-1', 'auto');
ga('send', 'pageview');</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"5WEDOKLFCL","apiKey":"26a57bfa5275b7c98a3b3ab7dae61915","indexName":"upupming-blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#a-increasing-substring"><span class="toc-number">1.</span> <span class="toc-text"> A. Increasing Substring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#算法-线性扫描"><span class="toc-number">1.1.</span> <span class="toc-text"> 算法 —— 线性扫描</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间复杂度"><span class="toc-number">1.2.</span> <span class="toc-text"> 时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-代码"><span class="toc-number">1.3.</span> <span class="toc-text"> C++ 代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b-longest-progression"><span class="toc-number">2.</span> <span class="toc-text"> B. Longest Progression</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#算法-差分贪心"><span class="toc-number">2.1.</span> <span class="toc-text"> 算法 —— 差分+贪心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间复杂度-2"><span class="toc-number">2.2.</span> <span class="toc-text"> 时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-代码-2"><span class="toc-number">2.3.</span> <span class="toc-text"> C++ 代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-consecutive-primes"><span class="toc-number">3.</span> <span class="toc-text"> C. Consecutive Primes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#算法-素数判断"><span class="toc-number">3.1.</span> <span class="toc-text"> 算法 —— 素数判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间复杂度-3"><span class="toc-number">3.2.</span> <span class="toc-text"> 时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-代码-3"><span class="toc-number">3.3.</span> <span class="toc-text"> C++ 代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#d-truck-delivery"><span class="toc-number">4.</span> <span class="toc-text"> D. Truck Delivery</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#暴力解法"><span class="toc-number">4.1.</span> <span class="toc-text"> 暴力解法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#算法-dfs-暴力"><span class="toc-number">4.1.1.</span> <span class="toc-text"> 算法 —— DFS + 暴力</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#时间复杂度-4"><span class="toc-number">4.1.2.</span> <span class="toc-text"> 时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-代码-4"><span class="toc-number">4.1.3.</span> <span class="toc-text"> C++ 代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优化解法"><span class="toc-number">4.2.</span> <span class="toc-text"> 优化解法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#算法-dfs-线段树"><span class="toc-number">4.2.1.</span> <span class="toc-text"> 算法 —— DFS + 线段树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#时间复杂度-5"><span class="toc-number">4.2.2.</span> <span class="toc-text"> 时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-代码-5"><span class="toc-number">4.2.3.</span> <span class="toc-text"> C++ 代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text"> 总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#开源代码"><span class="toc-number">6.</span> <span class="toc-text"> 开源代码</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/doraemon.jpeg"></div><div class="author-info__name text-center">upupming</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">52</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">44</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">27</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" href="https://molunerfinn.com/">MARKSZのBlog</a><a class="author-info-links__name text-center" href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md">提问的智慧</a><a class="author-info-links__name text-center" href="https://zh.wikipedia.org/">中文维基百科</a><a class="author-info-links__name text-center" href="https://zbqtesla.github.io">ZBQTesla的博客</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/background.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">upupming 的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="https://mirror.upupming.site">Mirror</a><a class="site-page" href="https://music.wxhbts.com">音乐</a><a class="site-page" href="https://writing.upupming.site">Writing</a><a class="site-page" href="/about">关于</a><a class="site-page" href="/rss">RSS</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">Google Kickstart 2021 Round B 题解</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-05-11</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/算法/">算法</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/算法/Kick-Start/">Kick Start</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">3.6k</span><span class="post-meta__separator">|</span><span>阅读时长: 16 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>Google Kickstart 2021 Round A 的题解，附上我的一些思考过程，希望对你有所帮助。</p>
<p>比 A 轮还是难一点，只拿了 37 分，思维和代码熟练度都欠缺，再接再厉。</p>
<ul>
<li>Score: 37</li>
<li>Rank: 1946</li>
</ul>
<a id="more"></a>
<h2 id="a-increasing-substring"><a class="markdownIt-Anchor" href="#a-increasing-substring"></a> A. Increasing Substring</h2>
<h3 id="算法-线性扫描"><a class="markdownIt-Anchor" href="#算法-线性扫描"></a> 算法 —— 线性扫描</h3>
<ul>
<li>
<p>从前到后扫描整个字符串，<code>dp[i]</code> 表示以 <code>i</code> 为结尾的最长单调子串的长度</p>
</li>
<li>
<p>转移方程为：</p>
<ul>
<li><code>dp[i] = dp[i]+1, s[i] &gt; s[i-1]</code></li>
<li><code>dp[i] = 1, s[i] &lt;= s[i-1]</code></li>
</ul>
</li>
<li>
<p>由于状态计算只需要使用上一个下标 <code>dp[i-1]</code> 的值，所以将数组可以优化成一个变量，滚动更新。</p>
</li>
</ul>
<h3 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度"></a> 时间复杂度</h3>
<ul>
<li>扫描一遍字符串: <code>O(n)</code></li>
</ul>
<h3 id="c-代码"><a class="markdownIt-Anchor" href="#c-代码"></a> C++ 代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, k;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt; s[i - <span class="number">1</span>])</span><br><span class="line">            dp += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s;</span><br><span class="line">        s = <span class="string">' '</span> + s;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: "</span>, i);</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="b-longest-progression"><a class="markdownIt-Anchor" href="#b-longest-progression"></a> B. Longest Progression</h2>
<p>比较复杂的一个分类讨论，当时没有梳理清楚逻辑关系，直接在 2020 RoundE Problem A 的基础上写的暴力（暴力枚举差分改变的地方，然后运行原来的朴素算法），<code>O(N^2)</code> 的所以会在 Test 2 上 TLE。</p>
<h3 id="算法-差分贪心"><a class="markdownIt-Anchor" href="#算法-差分贪心"></a> 算法 —— 差分+贪心</h3>
<ul>
<li>计算最长等差数列和 2020 RoundE Problem A 一样，是首先计算差分数组，然后统计差分数组里面最长的具有相同数的子串的长度 <code>len</code>，答案就是 <code>len+1</code>
<ul>
<li>例如: 原数组 <code>A=[1,3,4,7,9,11]</code>，差分数组 <code>D=[2,1,3,2,2]</code>（其中 <code>D[i] = A[i+1]-A[i], i = 1,...n-1</code>），最长相同数子串 <code>[2,2]</code>，长度为 2，对应最长等差数列为 <code>[7,9,11]</code>，长度为 3</li>
</ul>
</li>
<li>现在可以在原来的基础上修改一个数，修改一个数等价于修改两个差分值
<ul>
<li>不妨设你将 <code>A[i]</code> 增加 <code>x</code>，那么修改之后 <code>D[i-1]</code> 会增加 <code>x</code>，<code>D[i]</code> 会减少 <code>x</code>，两者的总和保持不变。这个修改对最终的差分数组的影响需要分情况讨论</li>
<li>可以先将差分数组分成若干段，每一段都是一个包含全部一样数 <code>d</code> 的子串，不妨设起始下标为 <code>D[i]</code>，长度为 <code>k</code></li>
<li>我们一定是修改下个子串的第一个差分值让其等于当前子串的差分值，这样能使答案优于不改变任何数的时候的答案</li>
<li>改变了子串的第一个差分值 <code>D[i+k]</code> 之后，会对紧接着的差分值 <code>D[i+k+1]</code> 产生影响，需要分情况考虑</li>
<li>例子 1 (<code>D[i+k] + D[i+k+1] != 2d</code>): <code>D=[1,1],[3],[0,0]</code>，考虑第 1 个子串，修改第 2 个子串的第一个数之后就是: <code>D=[1,1],[1],[2,0]</code>，最终的 <code>len=3</code></li>
<li>例子 2 (<code>D[i+k] + D[i+k+1] == 2d, D[i+k+2] != d</code>): <code>D=[1,1],[2],[0,0]</code>，考虑第 1 个子串，修改第 2 个子串的第一个数之后就是: <code>D=[1,1],[1],[1,0]</code>，最终的 <code>len=4</code></li>
<li>例子 3 (<code>D[i+k] + D[i+k+1] == 2d, D[i+k+2] == d</code>): <code>D=[2],[1],[3],[2,2]</code>，考虑第 1 个子串，修改第 2 个子串的第一个数之后就是: <code>D=[2],[2],[2],[2,2]</code>，最终的 <code>len=5</code></li>
</ul>
</li>
</ul>
<h3 id="时间复杂度-2"><a class="markdownIt-Anchor" href="#时间复杂度-2"></a> 时间复杂度</h3>
<ul>
<li>预处理差分数组、按照相等值分段: <code>O(N)</code></li>
<li>依次考虑每块，并且对于每一块，考虑上面 3 种情况: <code>O(N)</code></li>
</ul>
<h3 id="c-代码-2"><a class="markdownIt-Anchor" href="#c-代码-2"></a> C++ 代码</h3>
<ul>
<li>实际实现时，没有必要存储每个子串的长度 <code>k</code>，可以通过 <code>upper_bound</code> 实现，用 <code>set</code> 只会增加一个 <code>log</code> 的时间复杂度</li>
<li>对于例子 <code>A=[1,0,1,1], D=[-1,1,0]</code>，最优解是修改第 1 和第 2 个差分值，为了避免特殊判断，将 D 反转重新算一遍取最大即可</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, a[N], d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        d[i] = a[i + <span class="number">1</span>] - a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每一个子串的起始下标</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; startPos;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span> || d[i] != d[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">// i 是一个新的分段的起点</span></span><br><span class="line">            startPos.insert(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 哨兵</span></span><br><span class="line">    startPos.insert(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举所有的子串，尝试修改后面的子串的第 1 个值</span></span><br><span class="line">    <span class="keyword">int</span> m = startPos.size(), ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = startPos.begin(); it != startPos.end(); it++) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = *it, val = d[i];</span><br><span class="line">        <span class="keyword">if</span> (i &gt; n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">auto</span> it2 = it;</span><br><span class="line">        it2++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// j 是下一个子串的开头</span></span><br><span class="line">        <span class="keyword">int</span> j = *it2;</span><br><span class="line">        <span class="comment">// 区间 [i, j)</span></span><br><span class="line">        <span class="keyword">int</span> tmp = j - i;</span><br><span class="line">        <span class="comment">// 区间 [i, j]</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt;= n - <span class="number">1</span>) tmp++;</span><br><span class="line">        <span class="comment">// 区间 [i, j+1]</span></span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= n - <span class="number">1</span> &amp;&amp; d[j] + d[j + <span class="number">1</span>] == <span class="number">2</span> * val) &#123;</span><br><span class="line">            tmp++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">2</span> &lt;= n - <span class="number">1</span> &amp;&amp; d[j + <span class="number">2</span>] == val) &#123;</span><br><span class="line">                <span class="keyword">int</span> k = *startPos.upper_bound(j + <span class="number">2</span>);</span><br><span class="line">                <span class="comment">// 区间 [i, k)</span></span><br><span class="line">                assert(k &lt;= n &amp;&amp; d[k - <span class="number">1</span>] == val);</span><br><span class="line">                tmp = k - i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans1 = solve();</span><br><span class="line">        reverse(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">int</span> ans2 = solve();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %d\n"</span>, i, max(ans1, ans2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="c-consecutive-primes"><a class="markdownIt-Anchor" href="#c-consecutive-primes"></a> C. Consecutive Primes</h2>
<p>比赛的时候想到了先用线性筛计算 <code>[1, sqrt(Z)]</code> 范围内的素数，然后二分小因子的算法，总时间复杂度为 <code>O(sqrt{Z} + log cnt)</code>，其中 <code>cnt</code> 表示<code>[1, sqrt(Z)]</code> 范围内的素数总个数。显然无法过 Test 3。主要瓶颈在线性筛算法上。</p>
<blockquote>
<p>注：根据 <a href="https://cp-wiki.vercel.app/tutorial/kick-start/2021B/#problem-c-consecutive-primes" target="_blank" rel="noopener">lucifer1004</a> 的解释，用线性筛也是可以过的，但是要将线性筛外提，所有的测试用例只运行一次线性筛。不过这是因为 KickStart 评测机的时间限制比较宽裕，我们赛后还是要追求最好的解法。</p>
</blockquote>
<h3 id="算法-素数判断"><a class="markdownIt-Anchor" href="#算法-素数判断"></a> 算法 —— 素数判断</h3>
<ul>
<li>官方给的解析反倒更加简单，不需要用素数筛，只需要用素数判定算法即可，比第 2 题更加好实现，关键在于利用了条件「两个素数因子是相邻的」</li>
<li>假设最终的答案是 <code>N</code> (<code>N &lt;= Z</code>)，那么最终两个相邻素数因子一定是 3 种情况:
<ul>
<li><code>sqrt(Z)</code> 左侧最大、<code>sqrt(Z)</code> 右侧最小，这两个素数之积如果小于 <code>Z</code>，那么一定是答案</li>
<li>否则，<code>sqrt(Z)</code> 左侧最近的两个素数，这两个素数之积一定小于 <code>Z</code></li>
</ul>
</li>
<li>根据<a href="https://en.wikipedia.org/wiki/Prime_gap" target="_blank" rel="noopener">素数的数学性质</a>，可以知道 <code>Z=1e18, sqrt(Z)=1e9</code> 时，临近的质数之差的绝对值不会超过 282，直接暴力的枚举即可</li>
<li>这样看来，第三题比第二题是线上还简单很多，主要是有需要一个思维上的转变</li>
</ul>
<h3 id="时间复杂度-3"><a class="markdownIt-Anchor" href="#时间复杂度-3"></a> 时间复杂度</h3>
<ul>
<li>枚举三个数: <code>O(282 * 3)</code>
<ul>
<li>判断是否是质数: <code>fourth_root(z)</code> （<code>z</code> 的四次方根）</li>
</ul>
</li>
<li>总时间复杂度: <code>O(282 * 3 * fourth_root(z))</code></li>
</ul>
<h3 id="c-代码-3"><a class="markdownIt-Anchor" href="#c-代码-3"></a> C++ 代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">LL z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">2</span>; i &lt;= x / i; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL x = <span class="built_in">sqrt</span>(z), a, b, c;</span><br><span class="line"></span><br><span class="line">    LL t = x;</span><br><span class="line">    <span class="keyword">for</span> (; !is_prime(t); t--) &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    b = t--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Z = 6 时，特殊情况，不存在第二小的质因子 a</span></span><br><span class="line">    <span class="keyword">if</span> (t &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        a = z;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; !is_prime(t); t--) &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">        a = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t = x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; !is_prime(t); t++) &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    c = t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b * c &lt;= z) <span class="keyword">return</span> b * c;</span><br><span class="line">    <span class="keyword">if</span> (a * b &lt;= z) <span class="keyword">return</span> a * b;</span><br><span class="line">    assert(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; z;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>, i, solve());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="d-truck-delivery"><a class="markdownIt-Anchor" href="#d-truck-delivery"></a> D. Truck Delivery</h2>
<h3 id="暴力解法"><a class="markdownIt-Anchor" href="#暴力解法"></a> 暴力解法</h3>
<blockquote>
<p>暴力解法只能过 Test 1</p>
</blockquote>
<h4 id="算法-dfs-暴力"><a class="markdownIt-Anchor" href="#算法-dfs-暴力"></a> 算法 —— DFS + 暴力</h4>
<ul>
<li>DFS 一遍，计算每个点的到 1 的简单路径，记录 <code>pre</code> 数组，这里使用常用的遍历无向树的套路：dfs 参数 <code>x</code> 表示正在遍历的节点, <code>father</code> 记录从哪个方向来的，下一个节点不是 <code>father</code> 的时候往下遍历</li>
<li>初始化答案 <code>ans=0</code>，对于每一个查询，枚举路径上所有的点，依次比较每条边 <code>l</code> 值和当前查询的 <code>w</code>，看是否要更新答案 <code>ans = gcd(ans, a)</code>。</li>
</ul>
<h4 id="时间复杂度-4"><a class="markdownIt-Anchor" href="#时间复杂度-4"></a> 时间复杂度</h4>
<ul>
<li>DFS: <code>O(N)</code></li>
<li>遍历所有询问: <code>O(Q)</code>
<ul>
<li>每个询问需要访问路径上所有的边，最坏情况下最长边为 <code>N-1</code>: <code>O(N)</code>
<ul>
<li>最多每条边计算一次 gcd</li>
</ul>
</li>
<li>计算 N 个数的 gcd 的总时间复杂度为 <code>O(N + log(max{A}))</code>，注意不是 <code>O(N * log(max{A}))</code>，证明先略去</li>
</ul>
</li>
<li>总时间复杂度: <code>O(Q(N + log(max{A})))</code></li>
</ul>
<h4 id="c-代码-4"><a class="markdownIt-Anchor" href="#c-代码-4"></a> C++ 代码</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">10</span>, Q = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, q, pre[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[N];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, LL&gt;&gt; L, A;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    pre[x] = fa;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;y : e[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y != fa) &#123;</span><br><span class="line">            dfs(y, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="keyword">sizeof</span> pre);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> c, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c &gt;&gt; w;</span><br><span class="line">        LL ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (c != <span class="number">1</span>) &#123;</span><br><span class="line">            LL l = L[c][pre[c]], a = A[c][pre[c]];</span><br><span class="line">            <span class="keyword">if</span> (w &gt;= l) &#123;</span><br><span class="line">                ans = gcd(ans, a);</span><br><span class="line">            &#125;</span><br><span class="line">            c = pre[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) e[i].clear();</span><br><span class="line">        L.clear(), A.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            LL x, y, l, a;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; l &gt;&gt; a;</span><br><span class="line">            e[x].push_back(y);</span><br><span class="line">            e[y].push_back(x);</span><br><span class="line">            L[x][y] = L[y][x] = l;</span><br><span class="line">            A[x][y] = A[y][x] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: "</span>, i);</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化解法"><a class="markdownIt-Anchor" href="#优化解法"></a> 优化解法</h3>
<h4 id="算法-dfs-线段树"><a class="markdownIt-Anchor" href="#算法-dfs-线段树"></a> 算法 —— DFS + 线段树</h4>
<ul>
<li>基于离线查询进行优化，按照特定顺序填充答案，降低时间复杂度</li>
<li>在 DFS 的过程中维护一个表示当前路径的线段树
<ul>
<li>线段树的 key 为每条边的 load <code>l</code>
<ul>
<li>这里有一个很重要的点，是说，所有的 <code>l</code> 是不同的（启发我们题目的数据范围一定要要仔细看），这就避免出现一个 key 有多个 value 的情况发生</li>
</ul>
</li>
<li>线段树的 value 为每条边的 amount <code>a</code>，初始值为 0 表示不存在
<ul>
<li>删除的时候也是直接将 value 置为 0</li>
</ul>
</li>
<li>线段树的 merge 方式为 <code>gcd()</code></li>
</ul>
</li>
<li>在 DFS 搜索到 <code>x</code> 的时候，如果查询中存在当前节点 <code>x</code>，且负重为 <code>w</code>，只需要在线段数中查询所有 <code>&lt;=w</code> 区间范围内的 <code>l</code> 的所有 <code>a</code> 值的 <code>gcd()</code></li>
</ul>
<h4 id="时间复杂度-5"><a class="markdownIt-Anchor" href="#时间复杂度-5"></a> 时间复杂度</h4>
<ul>
<li>DFS: <code>O(N + Q)</code>
<ul>
<li>同时维护线段树:
<ul>
<li>维护的时间复杂度为 <code>log(max{L})</code></li>
<li>最多只需要计算 <code>log(max{L})</code> 个数的 gcd: <code>O(log(max{L}) + log(max{A}))</code></li>
</ul>
</li>
</ul>
</li>
<li>总时间复杂度: <code>O[(N + Q)(log(max{L}) + log(max{A}))]</code></li>
</ul>
<h4 id="c-代码-5"><a class="markdownIt-Anchor" href="#c-代码-5"></a> C++ 代码</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">10</span>, Q = <span class="number">1e5</span> + <span class="number">10</span>, LMax = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, q;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[N];</span><br><span class="line"><span class="comment">// 节点 x 的所有询问: pair&lt;w, index&gt;</span></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; query[N];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; L;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, LL&gt;&gt; A;</span><br><span class="line">LL ans[Q];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    LL dat;</span><br><span class="line">&#125; tree[LMax * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线段树的建树，时间复杂度：O(N)</span></span><br><span class="line"><span class="comment">// p 表示节点编号，[l, r] 表示节点所代表的区间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    tree[p].l = l, tree[p].r = r;</span><br><span class="line">    <span class="comment">// 叶节点，表示单个元素</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tree[p].dat = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 左子节点：编号为 2*p，代表区间 [l, mid]</span></span><br><span class="line">    build(<span class="number">2</span> * p, l, mid);</span><br><span class="line">    <span class="comment">// 右子节点：编号为 2*p+1，代表区间 [mid+1, r]</span></span><br><span class="line">    build(<span class="number">2</span> * p + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">// 从下往上合并更新信息</span></span><br><span class="line">    tree[p].dat = gcd(tree[<span class="number">2</span> * p].dat, tree[<span class="number">2</span> * p + <span class="number">1</span>].dat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线段树的单点修改，时间复杂度：O(log N)</span></span><br><span class="line"><span class="comment">// 将 a[x] 的值修改为 v</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, LL v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到叶节点</span></span><br><span class="line">    <span class="keyword">if</span> (tree[p].l == tree[p].r) &#123;</span><br><span class="line">        tree[p].dat = v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[p].l + tree[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// x 属于左半区间</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) change(<span class="number">2</span> * p, x, v);</span><br><span class="line">    <span class="comment">// x 属于右半区间</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        change(<span class="number">2</span> * p + <span class="number">1</span>, x, v);</span><br><span class="line">    <span class="comment">// 从下往上合并更新信息</span></span><br><span class="line">    tree[p].dat = gcd(tree[<span class="number">2</span> * p].dat, tree[<span class="number">2</span> * p + <span class="number">1</span>].dat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线段树的区间查询，时间复杂度：O(log N)</span></span><br><span class="line"><span class="comment">// 查询序列 a 在区间 [l, r] 上的 gcd</span></span><br><span class="line"><span class="function">LL <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询区间 [l, r] 完全包含节点 p 所代表的的区间</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= tree[p].l &amp;&amp; r &gt;= tree[p].r) <span class="keyword">return</span> tree[p].dat;</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[p].l + tree[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    LL val = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 左子节点 [tree[p].l, mid] 与查询 [l, r] 有重合</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) val = gcd(val, ask(<span class="number">2</span> * p, l, r));</span><br><span class="line">    <span class="comment">// 右子节点 [mid+1, tree[p].r] 与查询 [l, r] 有重合</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt;= mid + <span class="number">1</span>) val = gcd(val, ask(<span class="number">2</span> * p + <span class="number">1</span>, l, r));</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert 之前没有插入过 l，对应题目没有重复 l 的条件「All L_i are distinct.」</span></span><br><span class="line">    assert(ask(<span class="number">1</span>, L[x][fa], L[x][fa]) == <span class="number">0</span>);</span><br><span class="line">    change(<span class="number">1</span>, L[x][fa], A[x][fa]);</span><br><span class="line">    <span class="comment">// 回答所有对 x 的查询</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[w, idx] : query[x]) &#123;</span><br><span class="line">        ans[idx] = ask(<span class="number">1</span>, <span class="number">0</span>, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;y : e[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y != fa) &#123;</span><br><span class="line">            dfs(y, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    change(<span class="number">1</span>, L[x][fa], <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(tree, <span class="number">0</span>, <span class="keyword">sizeof</span> tree);</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span> ans);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">0</span>, LMax);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) query[i].clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> c, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c &gt;&gt; w;</span><br><span class="line">        query[c].push_back(make_pair(w, i));</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) e[i].clear();</span><br><span class="line">        L.clear(), A.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y, l;</span><br><span class="line">            LL a;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; l &gt;&gt; a;</span><br><span class="line">            e[x].push_back(y);</span><br><span class="line">            e[y].push_back(x);</span><br><span class="line">            L[x][y] = L[y][x] = l;</span><br><span class="line">            A[x][y] = A[y][x] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: "</span>, i);</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<ol>
<li>思路比较乱的时候，先不要实现，不然徒劳无功。真不行了，可以先实现朴素算法，再做改进。</li>
<li>没有明确思路的时候，先把所有的题目看完，可能出现后面的题目更简单的情况。（这次都没有留下时间仔细想最后一题）</li>
<li>数据范围还是需要仔细看。</li>
</ol>
<h2 id="开源代码"><a class="markdownIt-Anchor" href="#开源代码"></a> 开源代码</h2>
<p>代码已经放在 GitHub: <a href="https://github.com/upupming/algorithm/tree/master/kick-start/2021/RoundB" target="_blank" rel="noopener">https://github.com/upupming/algorithm/tree/master/kick-start/2021/RoundB</a> ，大家多多 clone，也可以随手 star 一下~</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">upupming</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://upupming.site/2021/05/11/kick-start-2021-round-b/">https://upupming.site/2021/05/11/kick-start-2021-round-b/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://upupming.site">upupming 的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/algorithm/">algorithm</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/06/05/kick-start-2021-round-c/"><i class="fa fa-chevron-left">  </i><span>Google Kickstart 2021 Round C 题解</span></a></div><div class="next-post pull-right"><a href="/2021/04/03/vcpkg-best-practice/"><span>The best practice for vcpkg &amp; Qt QML application -- manage C++ libraries with an ease</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'wiHsGgANF4mLmK2Hiubzew03-gzGzoHsz',
  appKey:'Tk0WjoOhLD8ppTfyhdCbyeDT',
  placeholder:'Just go go',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(/img/background.png)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2024 By upupming</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>