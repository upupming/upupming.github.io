<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="co 源码分析、迭代器、生成器、async/wait 对比"><meta name="keywords" content="frontend"><meta name="author" content="upupming"><meta name="copyright" content="upupming"><title>co 源码分析、迭代器、生成器、async/wait 对比 | upupming 的博客</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.6.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="manifest" href="/manifest.json"><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#1B9EF3"><meta name="msapplication-TileColor" content="#1B9EF3"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#1B9EF3"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-2188191456032650',
  enable_page_level_ads: 'true'
});
</script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?295ad5c5a196e4964e20f74260711177";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-114899088-1', 'auto');
ga('send', 'pageview');</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"5WEDOKLFCL","apiKey":"26a57bfa5275b7c98a3b3ab7dae61915","indexName":"upupming-blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作"><span class="toc-number">1.</span> <span class="toc-text"> 准备工作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器和生成器"><span class="toc-number">1.1.</span> <span class="toc-text"> 迭代器和生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#相关代码"><span class="toc-number">1.2.</span> <span class="toc-text"> 相关代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#co-源码分析"><span class="toc-number">2.</span> <span class="toc-text"> co 源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#从-ts-类型入手"><span class="toc-number">2.1.</span> <span class="toc-text"> 从 TS 类型入手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#extracttype-抽取可迭代对象的-return-值"><span class="toc-number">2.1.1.</span> <span class="toc-text"> ExtractType —— 抽取可迭代对象的 return 值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#co-传入生成器函数返回一个-promise"><span class="toc-number">2.1.2.</span> <span class="toc-text"> Co —— 传入生成器函数返回一个 Promise</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从使用例子入手分析-co-的实现"><span class="toc-number">2.2.</span> <span class="toc-text"> 从使用例子入手分析 co 的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#eg-1-cogen"><span class="toc-number">2.2.1.</span> <span class="toc-text"> Eg. 1: co(*gen)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#eg-11-普通使用"><span class="toc-number">2.2.1.1.</span> <span class="toc-text"> Eg. 1.1: 普通使用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#使用方法"><span class="toc-number">2.2.1.1.1.</span> <span class="toc-text"> 使用方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#co-实现代码"><span class="toc-number">2.2.1.1.2.</span> <span class="toc-text"> co 实现代码</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#eg-12-yield-promise-数组"><span class="toc-number">2.2.1.2.</span> <span class="toc-text"> Eg. 1.2: yield Promise 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#使用方法-2"><span class="toc-number">2.2.1.2.1.</span> <span class="toc-text"> 使用方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#co-实现代码-2"><span class="toc-number">2.2.1.2.2.</span> <span class="toc-text"> co 实现代码</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#eg-13-错误处理"><span class="toc-number">2.2.1.3.</span> <span class="toc-text"> Eg. 1.3: 错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#使用方法-3"><span class="toc-number">2.2.1.3.1.</span> <span class="toc-text"> 使用方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#co-实现代码-3"><span class="toc-number">2.2.1.3.2.</span> <span class="toc-text"> co 实现代码</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#eg-14-对象处理"><span class="toc-number">2.2.1.4.</span> <span class="toc-text"> Eg. 1.4: 对象处理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#使用方法-4"><span class="toc-number">2.2.1.4.1.</span> <span class="toc-text"> 使用方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#co-实现代码-4"><span class="toc-number">2.2.1.4.2.</span> <span class="toc-text"> co 实现代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eg2-cowrapgen"><span class="toc-number">2.2.2.</span> <span class="toc-text"> Eg.2: co.wrap(*gen)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">3.</span> <span class="toc-text"> 总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/doraemon.jpeg"></div><div class="author-info__name text-center">upupming</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">52</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">44</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">27</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" href="https://molunerfinn.com/">MARKSZのBlog</a><a class="author-info-links__name text-center" href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md">提问的智慧</a><a class="author-info-links__name text-center" href="https://zh.wikipedia.org/">中文维基百科</a><a class="author-info-links__name text-center" href="https://zbqtesla.github.io">ZBQTesla的博客</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/background.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">upupming 的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="https://mirror.upupming.site">Mirror</a><a class="site-page" href="https://music.wxhbts.com">音乐</a><a class="site-page" href="https://writing.upupming.site">Writing</a><a class="site-page" href="/about">关于</a><a class="site-page" href="/rss">RSS</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">co 源码分析、迭代器、生成器、async/wait 对比</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-29</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/前端/">前端</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/前端/源码阅读/">源码阅读</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">3.8k</span><span class="post-meta__separator">|</span><span>阅读时长: 16 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h2>
<h3 id="迭代器和生成器"><a class="markdownIt-Anchor" href="#迭代器和生成器"></a> 迭代器和生成器</h3>
<p>关于迭代器和生成器，我看的是《深入理解 ES6》，里面讲的很好，如果有不理解的同学，可以先补一补，英文版是开源的，在<a href="https://github.com/nzakas/understandinges6/blob/master/manuscript/08-Iterators-And-Generators.md" target="_blank" rel="noopener">这里</a>。</p>
<a id="more"></a>
<p>关于迭代器和生成器几点简单的总结：</p>
<ul>
<li>迭代器: <strong>Iterators</strong> are just objects with a specific interface designed for iteration. All iterator objects have a <code>next()</code> method that returns a result object.</li>
<li>生成器: A <strong>generator</strong> is a function that returns an iterator.</li>
<li>可迭代对象: Closely related to iterators, an <strong>iterable</strong> is an object with a <code>Symbol.iterator</code> property.</li>
</ul>
<h3 id="相关代码"><a class="markdownIt-Anchor" href="#相关代码"></a> 相关代码</h3>
<p>为了便于源码分析，我把 <a href="../co"><code>co</code> 源码</a>和它的类型定义 <a href="../DefinitelyTyped/types/co"><code>@types/co</code></a> 都拉取下来了，并且使用 yarn workspace 管理依赖，并且将我的一些测试代码写在了 <a href="./test/co.spec.ts">test/co.spec.ts</a> 和 <a href="test/co.type.spec.d.ts">test/co.type.spec.d.ts</a> 中。所有源代码均可在 <a href="https://github.com/upupming/koa-analysis/" target="_blank" rel="noopener">https://github.com/upupming/koa-analysis/</a> 获取，原文链接在: <a href="https://github.com/upupming/koa-analysis/tree/master/co-analysis/README.md" target="_blank" rel="noopener">https://github.com/upupming/koa-analysis/tree/master/co-analysis/README.md</a> 。</p>
<h2 id="co-源码分析"><a class="markdownIt-Anchor" href="#co-源码分析"></a> co 源码分析</h2>
<p>co 最新版是 v4.6.0，是 2015-07-09 发布的，距今已经 6 年多了，可见已经比较稳定，或者说现在基于 async/await 编程的话，根本是不需要 <code>co</code> 这个东西的。他的 <a href="http://README.md" target="_blank" rel="noopener">README.md</a> 也说了，对于 <code>co@4.0.0</code> 「It is a stepping stone towards the <a href="https://github.com/lukehoban/ecmascript-asyncawait" target="_blank" rel="noopener">async/await proposal</a>.」，返回类型用 Promise 替代了原来的 “thunk”。类型定义 <code>@types/co</code> 最后一次更新是在 2019-06-05，比较老旧。</p>
<p>我先从使用方法入手，然后深入源码逐一分析。</p>
<h3 id="从-ts-类型入手"><a class="markdownIt-Anchor" href="#从-ts-类型入手"></a> 从 TS 类型入手</h3>
<p>熟悉代码之前，我们先熟悉 TS 类型，搞清楚 <code>co</code> 的传入参数，返回值都是什么类型的。</p>
<blockquote>
<p>看完 <code>@types/co</code> 的源码之后，觉得他在 generator 返回值类型的抽取定义可能稍微不太准确。我提了一个 PR 优化 <code>co</code> 的 <code>ExtractType</code> 类型: <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/pull/55440" target="_blank" rel="noopener">https://github.com/DefinitelyTyped/DefinitelyTyped/pull/55440</a></p>
<p>不过确实 JS 是比较动态的语言，<code>co</code> 的逻辑比较复杂，能够处理的情况比较多，但是 TS 要精确表达每一种情况下的输入输出类型情况比较麻烦。</p>
</blockquote>
<h4 id="extracttype-抽取可迭代对象的-return-值"><a class="markdownIt-Anchor" href="#extracttype-抽取可迭代对象的-return-值"></a> <code>ExtractType</code> —— 抽取可迭代对象的 return 值</h4>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入一个可迭代对象类型 `I`，返回这个可迭代对象最终的 return 类型</span></span><br><span class="line"><span class="comment"> * 如果 `I` 不是可迭代对象：</span></span><br><span class="line"><span class="comment"> * 如果是函数，则返回函数的返回值</span></span><br><span class="line"><span class="comment"> * 如果是别的类型，直接返回 I 本身</span></span><br><span class="line"><span class="comment"> * 关于迭代器和生成器的类型使用方法详见: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-6.html</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ExtractType&lt;I&gt; = I <span class="keyword">extends</span> &#123; [Symbol.iterator]: <span class="function"><span class="params">()</span> =&gt;</span> Iterator&lt;<span class="built_in">any</span>, infer TReturn, <span class="built_in">any</span>&gt; &#125; ? TReturn :</span><br><span class="line">  I <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span> ? ReturnType&lt;I&gt; : I</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 TS 里面的 Generator 继承自 Iterator，本质上还是一个可迭代对象，GeneratorFunction 才是生成函数的类型定义</span></span><br><span class="line"><span class="comment">// yield number, return string, next boolean</span></span><br><span class="line"><span class="keyword">type</span> A = ExtractType&lt;Generator&lt;<span class="built_in">number</span>, <span class="built_in">string</span>, <span class="built_in">boolean</span>&gt;&gt;</span><br><span class="line"><span class="comment">// yield number, no return, next boolean</span></span><br><span class="line"><span class="keyword">type</span> B = ExtractType&lt;Generator&lt;<span class="built_in">number</span>, <span class="literal">undefined</span>, <span class="built_in">boolean</span>&gt;&gt;</span><br><span class="line"><span class="comment">// no yield number, return string, next boolean</span></span><br><span class="line"><span class="keyword">type</span> C = ExtractType&lt;Generator&lt;<span class="literal">undefined</span>, <span class="built_in">string</span>, <span class="built_in">boolean</span>&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> extractTypeCases = [</span><br><span class="line">  <span class="comment">// 可以看到 ExtractType 拿出来的都是 TReturn 类型</span></span><br><span class="line">  Expect&lt;Equal&lt;A, <span class="built_in">string</span>&gt;&gt;,</span><br><span class="line">  Expect&lt;Equal&lt;B, <span class="literal">undefined</span>&gt;&gt;,</span><br><span class="line">  Expect&lt;Equal&lt;C, <span class="built_in">string</span>&gt;&gt;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="co-传入生成器函数返回一个-promise"><a class="markdownIt-Anchor" href="#co-传入生成器函数返回一个-promise"></a> <code>Co</code> —— 传入生成器函数返回一个 Promise</h4>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接下来是 co 自己的类型声明，是一个函数，有泛型 `F`</span></span><br><span class="line"><span class="comment"> * 传入 `fn` 的的类型 `F` 是一个返回 Iterator 的函数，所以很自然地可以是 Generator Function</span></span><br><span class="line"><span class="comment"> * 传入的参数 `args` 是 `F` 的参数类型</span></span><br><span class="line"><span class="comment"> * 返回一个 Promise，Promise 的返回值是 `F` 返回的 Generator 的 `ExtractType` 结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// type Co&lt;F extends (...args: any[]) =&gt; Iterator&lt;any&gt;&gt; = (fn: F, ...args: Parameters&lt;F&gt;) =&gt; Promise&lt;ExtractType&lt;ReturnType&lt;F&gt;&gt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Co&lt;F <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; Iterator&lt;<span class="built_in">any</span>, <span class="built_in">any</span>, <span class="built_in">any</span>&gt;&gt; = <span class="function">(<span class="params">fn: F, ...args: Parameters&lt;F&gt;</span>) =&gt;</span> <span class="built_in">Promise</span>&lt;ExtractType&lt;ReturnType&lt;F&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">d</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">string</span>, z: <span class="built_in">boolean</span></span>): <span class="title">Generator</span>&lt;<span class="title">boolean</span>, <span class="title">string</span>, <span class="title">number</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ret = <span class="keyword">yield</span> <span class="literal">false</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a'</span>, ret)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> D = <span class="keyword">typeof</span> d</span><br><span class="line"><span class="comment">// 把 D 作为参数传给 Co 的时候，看一下返回类型</span></span><br><span class="line"><span class="keyword">type</span> E = ReturnType&lt;Co&lt;D&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> F = <span class="function"><span class="params">()</span> =&gt;</span> Generator&lt;<span class="built_in">boolean</span>, <span class="literal">undefined</span>, <span class="built_in">number</span>&gt;</span><br><span class="line"><span class="keyword">type</span> G = ReturnType&lt;Co&lt;F&gt;&gt;</span><br><span class="line"><span class="keyword">type</span> H = <span class="function"><span class="params">()</span> =&gt;</span> Generator&lt;<span class="literal">undefined</span>, <span class="built_in">string</span>, <span class="built_in">number</span>&gt;</span><br><span class="line"><span class="keyword">type</span> I = ReturnType&lt;Co&lt;H&gt;&gt;</span><br><span class="line"><span class="comment">// 可以看到最终 Co 函数的返回类型就是 Promise&lt;yield | return&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> coCases = [</span><br><span class="line">  Expect&lt;Equal&lt;E, <span class="built_in">Promise</span>&lt;<span class="built_in">string</span>&gt;&gt;&gt;,</span><br><span class="line">  Expect&lt;Equal&lt;G, <span class="built_in">Promise</span>&lt;<span class="literal">undefined</span>&gt;&gt;&gt;,</span><br><span class="line">  Expect&lt;Equal&lt;I, <span class="built_in">Promise</span>&lt;<span class="built_in">string</span>&gt;&gt;&gt;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Co['wrap'] 的话类型和 Co 是一模一样的，只是柯里化了一下，就不做介绍了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">wrap: &lt;F <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; Iterator&lt;<span class="built_in">any</span>, <span class="built_in">any</span>, <span class="built_in">any</span>&gt;&gt;<span class="function">(<span class="params">fn: F</span>) =&gt;</span> (...args: Parameters&lt;F&gt;) =&gt; <span class="built_in">Promise</span>&lt;ExtractType&lt;ReturnType&lt;F&gt;&gt;&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="从使用例子入手分析-co-的实现"><a class="markdownIt-Anchor" href="#从使用例子入手分析-co-的实现"></a> 从使用例子入手分析 <code>co</code> 的实现</h3>
<h4 id="eg-1-cogen"><a class="markdownIt-Anchor" href="#eg-1-cogen"></a> Eg. 1: <code>co(*gen)</code></h4>
<h5 id="eg-11-普通使用"><a class="markdownIt-Anchor" href="#eg-11-普通使用"></a> Eg. 1.1: 普通使用</h5>
<h6 id="使用方法"><a class="markdownIt-Anchor" href="#使用方法"></a> 使用方法</h6>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should work as documented'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> * <span class="title">gen</span> (<span class="params">a: number, b: string, c: boolean</span>): <span class="title">Generator</span>&lt;<span class="title">Promise</span>&lt;<span class="title">boolean</span>&gt;, <span class="title">boolean</span>, <span class="title">boolean</span>&gt; </span>&#123;</span><br><span class="line">    expect(a).toEqual(<span class="number">1</span>)</span><br><span class="line">    expect(b).toEqual(<span class="string">'2'</span>)</span><br><span class="line">    expect(c).toEqual(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">const</span> r1 = <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="literal">false</span>)</span><br><span class="line">    expect(r1).toEqual(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">const</span> r2 = <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="literal">true</span>)</span><br><span class="line">    expect(r2).toEqual(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">return</span> r2</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">await</span> co(gen, <span class="number">1</span>, <span class="string">'2'</span>, <span class="literal">true</span>)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      expect(value).toEqual(<span class="literal">true</span>)</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.error(err.stack)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>其实上面的代码等价于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should same as async/await'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fun = <span class="keyword">async</span> (a: number, <span class="attr">b</span>: string, <span class="attr">c</span>: boolean): <span class="built_in">Promise</span>&lt;boolean&gt; =&gt; &#123;</span><br><span class="line">    expect(a).toEqual(<span class="number">1</span>)</span><br><span class="line">    expect(b).toEqual(<span class="string">'2'</span>)</span><br><span class="line">    expect(c).toEqual(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">const</span> r1 = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="literal">false</span>)</span><br><span class="line">    expect(r1).toEqual(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">const</span> r2 = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="literal">true</span>)</span><br><span class="line">    expect(r2).toEqual(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">return</span> r2</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">await</span> fun(<span class="number">1</span>, <span class="string">'2'</span>, <span class="literal">true</span>)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      expect(value).toEqual(<span class="literal">true</span>)</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.error(err.stack)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>简单来说，在 <code>co</code> 包裹的 generator 内部连续使用 <code>yield</code> 的语法跟在 <code>async</code> 函数中连续使用 <code>await</code> 是一样的，async/await 是在 <a href="https://github.com/tc39/proposals/blob/master/finished-proposals.md" target="_blank" rel="noopener">2017 年也就是 ES2017 (ES8) 正式发布的</a>，比 <code>co</code> 出现还是晚很久（<code>co</code> 刚开始应该 Promise 都还没出来，用的是文档里面提到的 “thunk” 函数，就是一个带回调的函数 <code>function (callback) {...}</code>，这个可以参考《深入理解 ES6》的「异步任务执行器」一节的回调的代码模式）。所以可以理解为 generator function + co + promise = async/await。</p>
<p><code>co</code> 会使用传入的生成器函数创建一个迭代器，然后遍历这个迭代器，每次拿到迭代器 yield 出来的值 <code>ret</code>，就调用迭代器的 <code>.next(ret)</code> 将 <code>ret</code> 赋值给上面样例代码中的 <code>r1/r2</code>（可以参考《深入理解 ES6》的「给迭代器传递参数」和「向任务执行器传递数据」 这两节，这个逻辑和书上的样例是一模一样的）。迭代器结束的（<code>done=true</code>）时候，得到的值（也就是生成器函数里的 <code>return</code> 语句）作为 Promise 最后 resolve 的值。</p>
<h6 id="co-实现代码"><a class="markdownIt-Anchor" href="#co-实现代码"></a> <code>co</code> 实现代码</h6>
<p><code>co</code> 函数只有 60 行左右，非常简单，我加了一些注释：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 保存 this 指针</span></span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 保存 gen 后面所有参数</span></span><br><span class="line">  <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we wrap everything in a promise to avoid promise chaining,</span></span><br><span class="line">  <span class="comment">// which leads to memory leak errors.</span></span><br><span class="line">  <span class="comment">// see https://github.com/tj/co/issues/180</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 gen 是函数（注意 typeof generator function === 'function'），则执行这个函数</span></span><br><span class="line">    <span class="comment">// 显然对于 gen 是 generator function 的场景，赋值之后 gen 就变成了一个可迭代对象，后续可以和 yield 交互了</span></span><br><span class="line">    <span class="comment">// 如果传入的 gen 是一个普通函数，赋值之后 gen 就变成了这个函数的返回值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">'function'</span>) gen = gen.apply(ctx, args);</span><br><span class="line">    <span class="comment">// !gen 或者 gen.next 不是函数（也就是说 gen 不是一个可迭代对象的情况），直接 resolve gen</span></span><br><span class="line">    <span class="comment">// 其实我觉得这里更准确的方法应该是判断 typeof gen[Symbol.iterator] !== 'function'，因为生成器返回的迭代器（既是一个迭代器(有 `next` 方法)、又是一个可迭代对象(有 `Symbol.iterator` 属性)）一定都有 `Symbol.iterator` 属性，参考 https://stackoverflow.com/a/32538867/8242705</span></span><br><span class="line">    <span class="comment">// 其实也可以看 TS 类型定义 `Generator` 继承了 `Iterator`，并在其基础上多了一个 `Symbol.iterator` 属性</span></span><br><span class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">'function'</span>) <span class="keyword">return</span> resolve(gen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次调用 onFulfilled 不传参数，因为 gen.next(res) 第一次的传参没有意义，因为还没有执行任何 yield，第一次 next 的传参总是会被生成器忽略。具体的解释可以参考《深入理解 ES6》「给迭代器传递参数一节」</span></span><br><span class="line">    onFulfilled();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Mixed&#125;</span> <span class="variable">res</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return <span class="type">&#123;Promise&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@api <span class="variable">private</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> ret;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 给生成器传参 res，拿到 yield 出来的 ret 值</span></span><br><span class="line">        ret = gen.next(res);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// 如果发生预期外错误，最外层的 Promise 就 reject</span></span><br><span class="line">        <span class="keyword">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将 yield 出来的值传给 next，在我们的实例代码中，第一次这里 ret 就是一个 &#123; value: Promise&lt;1&gt;, done: false &#125;</span></span><br><span class="line">      next(ret);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Error&#125;</span> <span class="variable">err</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return <span class="type">&#123;Promise&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@api <span class="variable">private</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 就是调用 gen.throw 向生成器抛出错误的一个辅助函数</span></span><br><span class="line">    <span class="comment">// 可以参考《深入理解 ES6》「在迭代器中抛出错误」一节</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> ret;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = gen.throw(err);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// 如果发生预期外错误，最外层的 Promise 就 reject</span></span><br><span class="line">        <span class="keyword">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      next(ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the next value in the generator,</span></span><br><span class="line"><span class="comment">     * return a promise.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">ret</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return <span class="type">&#123;Promise&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@api <span class="variable">private</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">ret</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果生成器到达 return 语句，最外层 Promise resolve，从这里可以看出 co 总是 resolve 为生成器最终的返回值</span></span><br><span class="line">      <span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);</span><br><span class="line">      <span class="comment">// ret.val 可能是原生数据类型、Promise、数组、对象、或者这些东西的嵌套，这里有一层 toPromise 转换</span></span><br><span class="line">      <span class="keyword">var</span> value = toPromise.call(ctx, ret.value);</span><br><span class="line">      <span class="comment">// 转换成 promise 之后继续调用 onFulfilled, onRejected</span></span><br><span class="line">      <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected);</span><br><span class="line">      <span class="comment">// 如果转换出来不是 Promise 说明传了 co 不支持的类型，需要向生成器抛出错误</span></span><br><span class="line">      <span class="keyword">return</span> onRejected(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'You may only yield a function, promise, generator, array, or object, '</span></span><br><span class="line">        + <span class="string">'but the following object was passed: "'</span> + <span class="built_in">String</span>(ret.value) + <span class="string">'"'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有 then 函数就视为 promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPromise</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'function'</span> == <span class="keyword">typeof</span> obj.then;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="eg-12-yield-promise-数组"><a class="markdownIt-Anchor" href="#eg-12-yield-promise-数组"></a> Eg. 1.2: yield Promise 数组</h5>
<h6 id="使用方法-2"><a class="markdownIt-Anchor" href="#使用方法-2"></a> 使用方法</h6>
<p>另外 <code>co</code> 还支持传入数组，表现类似 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" target="_blank" rel="noopener"><code>Promise.all</code></a>，<a href="https://codereview.stackexchange.com/a/134230" target="_blank" rel="noopener">这里</a>有 <code>Promise.all</code> 的实现方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">co(<span class="function"><span class="keyword">function</span> * (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// resolve multiple promises in parallel</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> b = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">const</span> c = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">yield</span> [a, b, c]</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  expect(value).toEqual([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>会发现上面的代码等价于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> c = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">Promise</span>.all([a, b, c]).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  expect(value).toEqual([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h6 id="co-实现代码-2"><a class="markdownIt-Anchor" href="#co-实现代码-2"></a> <code>co</code> 实现代码</h6>
<p>其实主要体现在 <code>co</code> 对 yield 出来的值应用 <code>toPromise</code> 变换的方法，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toPromise</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!obj) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (isPromise(obj)) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (isGeneratorFunction(obj) || isGenerator(obj)) <span class="keyword">return</span> co.call(<span class="keyword">this</span>, obj);</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> obj) <span class="keyword">return</span> thunkToPromise.call(<span class="keyword">this</span>, obj);</span><br><span class="line">  <span class="comment">// 这里调用了 arrayToPromise</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(obj)) <span class="keyword">return</span> arrayToPromise.call(<span class="keyword">this</span>, obj);</span><br><span class="line">  <span class="keyword">if</span> (isObject(obj)) <span class="keyword">return</span> objectToPromise.call(<span class="keyword">this</span>, obj);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发现内部就是用的 Promise.all，对于数组中每个元素，递归调用 toPromise，这个递归太秀了，这样就可以很好地支持数组、对象的嵌套了，以后可以借鉴</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayToPromise</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(obj.map(toPromise, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="eg-13-错误处理"><a class="markdownIt-Anchor" href="#eg-13-错误处理"></a> Eg. 1.3: 错误处理</h5>
<h6 id="使用方法-3"><a class="markdownIt-Anchor" href="#使用方法-3"></a> 使用方法</h6>
<p><code>Promise</code> 的错误也是直接抛给了 generator function 自己。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">co(<span class="function"><span class="keyword">function</span> * (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'boom'</span>))</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    expect(err.message).toEqual(<span class="string">'boom'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这一点跟 async/await 的 try-catch 语法基本上是一样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'boom'</span>))</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  expect(err.message).toEqual(<span class="string">'boom'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="co-实现代码-3"><a class="markdownIt-Anchor" href="#co-实现代码-3"></a> <code>co</code> 实现代码</h6>
<p>其实这个的实现就体现在调用 <code>gen.throw</code> 的那些地方：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// onRejected 封装了 gen.throw</span></span><br><span class="line">    ret = gen.throw(err);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">  next(ret);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">ret</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 如果 yield 出来的 promise reject 了的话，调用 onRejected</span></span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected);</span><br><span class="line">    <span class="comment">// yield 出来的类型不对也调用 onRejected</span></span><br><span class="line">    <span class="keyword">return</span> onRejected(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'You may only yield a function, promise, generator, array, or object, '</span></span><br><span class="line">        + <span class="string">'but the following object was passed: "'</span> + <span class="built_in">String</span>(ret.value) + <span class="string">'"'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="eg-14-对象处理"><a class="markdownIt-Anchor" href="#eg-14-对象处理"></a> Eg. 1.4: 对象处理</h5>
<h6 id="使用方法-4"><a class="markdownIt-Anchor" href="#使用方法-4"></a> 使用方法</h6>
<p>对一个对象的所有 values 都是 Promise 的情况，能够异步执行，最终返回一个 values 都是 Promise resolve 之后的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">co(<span class="function"><span class="keyword">function</span> * (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">yield</span> &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">    <span class="number">2</span>: <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  expect(res).toEqual(&#123; <span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这个用 <code>Promise.all</code> 和 <code>Object.fromEntries</code> 也很容易实现:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="number">1</span>: <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">  <span class="number">2</span>: <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里利用了 Object.keys 和 Object.values 顺序保持一致的特性: https://stackoverflow.com/a/52706191/8242705</span></span><br><span class="line"><span class="keyword">const</span> tmp = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(<span class="built_in">Object</span>.values(obj))</span><br><span class="line"><span class="keyword">const</span> res = <span class="built_in">Object</span>.fromEntries(<span class="built_in">Object</span>.keys(obj).map(<span class="function">(<span class="params">key, idx</span>) =&gt;</span> [key, tmp[idx]]))</span><br><span class="line">expect(res).toEqual(&#123; <span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span> &#125;)</span><br></pre></td></tr></table></figure>
<h6 id="co-实现代码-4"><a class="markdownIt-Anchor" href="#co-实现代码-4"></a> <code>co</code> 实现代码</h6>
<p>和传数组类似，代码主要体现在 <code>toPromise</code> 如何处理对象类型的数据。他这里没有使用我上面的方法，而还是用了 <code>Object.keys</code> 和 <code>Promise.all</code> 以及闭包结合来实现。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toPromise</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!obj) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (isPromise(obj)) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (isGeneratorFunction(obj) || isGenerator(obj)) <span class="keyword">return</span> co.call(<span class="keyword">this</span>, obj);</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> obj) <span class="keyword">return</span> thunkToPromise.call(<span class="keyword">this</span>, obj);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(obj)) <span class="keyword">return</span> arrayToPromise.call(<span class="keyword">this</span>, obj);</span><br><span class="line">  <span class="comment">// 这里调用 objectToPromise</span></span><br><span class="line">  <span class="keyword">if</span> (isObject(obj)) <span class="keyword">return</span> objectToPromise.call(<span class="keyword">this</span>, obj);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectToPromise</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> results = <span class="keyword">new</span> obj.constructor();</span><br><span class="line">  <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">  <span class="comment">// 按 keys 顺序存成一个 promises 数组，后续传给 Promise.all 异步执行</span></span><br><span class="line">  <span class="keyword">var</span> promises = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> key = keys[i];</span><br><span class="line">    <span class="comment">// 这里又是对 obj[key] 递归调用 toPromise 来转换为 Promise，值得借鉴</span></span><br><span class="line">    <span class="keyword">var</span> promise = toPromise.call(<span class="keyword">this</span>, obj[key]);</span><br><span class="line">    <span class="comment">// 如果是一个 Promise，等其 resolve 之后将结果放入 results 对象</span></span><br><span class="line">    <span class="keyword">if</span> (promise &amp;&amp; isPromise(promise)) defer(promise, key);</span><br><span class="line">    <span class="comment">// 否则直接放入 results 对象</span></span><br><span class="line">    <span class="keyword">else</span> results[key] = obj[key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等 promise resolve 之后将其结果放入 results[key] 中</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">defer</span>(<span class="params">promise, key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// predefine the key in the result</span></span><br><span class="line">    results[key] = <span class="literal">undefined</span>;</span><br><span class="line">    promises.push(promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">      results[key] = res;</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="eg2-cowrapgen"><a class="markdownIt-Anchor" href="#eg2-cowrapgen"></a> Eg.2: <code>co.wrap(*gen)</code></h4>
<p><code>co.wrap</code> 就是 <code>co</code> 本身的一层简单封装，不像 <code>co</code> 那样直接把参数传给 generator function 了，而是拿到一个函数可以多次执行，每次执行的时候再传参，其实就是简单地柯里化一下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = co.wrap(<span class="function"><span class="keyword">function</span> * (<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(val)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fn(<span class="literal">true</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">  expect(val).toEqual(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>一个 <code>async</code> 函数本身就可以被以不同的参数调用多次，所以 <code>wrap</code> 应该不需要 <code>async</code> 下的等价形式。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="keyword">async</span> (val): <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(val)</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="literal">true</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">  expect(val).toEqual(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>下面是他的实现源码，非常简单，常规的柯里化操作，返回一个函数，每次调用这个函数都相当于用一次 <code>co(fn, arguments)</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">co.wrap = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createPromise() &#123;</span><br><span class="line">    <span class="keyword">return</span> co.call(<span class="keyword">this</span>, fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>传统的基于回调函数的异步模式写起来很不好，容易造成回调地狱，<code>co</code> 相当于一种语法糖，并且如作者所说，「It is a stepping stone towards the <a href="https://github.com/lukehoban/ecmascript-asyncawait" target="_blank" rel="noopener">async/await proposal</a>.」。<code>co</code> 利用 generator function 中的 <code>yield</code> 和 <code>next</code> 可以让异步代码编写起来非常自然，当如今 <code>Promise</code> 和 <code>async/await</code> 加入 ES 新标准多年，都已经非常成熟了，<code>co</code> 也就逐渐不怎么需要了，但是我们从中可以看到 <code>async/await</code> 其实是可以用 generator function 来做 polyfill 的。</p>
<p><code>co</code> 里面最主要的工具函数主要是递归的实现 <code>toPromise</code>，对嵌套对象可以进行递归转换，以后有需要可以借鉴。</p>
<p>所有的测试用例和代码均放在 <a href="https://github.com/upupming/koa-analysis" target="_blank" rel="noopener">https://github.com/upupming/koa-analysis</a> ，可以 clone 下来看看 <a href="test/co.spec.ts">co.spec.ts</a> 和 <a href="test/co.type.spec.d.ts">co.type.spec.d.ts</a>，原文链接在: <a href="https://github.com/upupming/koa-analysis/tree/master/co-analysis/README.md" target="_blank" rel="noopener">https://github.com/upupming/koa-analysis/tree/master/co-analysis/README.md</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">upupming</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://upupming.site/2021/08/29/co-analysis/">https://upupming.site/2021/08/29/co-analysis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://upupming.site">upupming 的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/frontend/">frontend</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/10/11/create-vue-learning/"><i class="fa fa-chevron-left">  </i><span>create-vue 发布并成为官方推荐，未来将替换 vue cli，看看 Vue Contributor Days 说了哪些内容（附 create-vue 源码解析）</span></a></div><div class="next-post pull-right"><a href="/2021/08/29/vue-release/"><span>Vue 3 发版流程源码分析</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'wiHsGgANF4mLmK2Hiubzew03-gzGzoHsz',
  appKey:'Tk0WjoOhLD8ppTfyhdCbyeDT',
  placeholder:'Just go go',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(/img/background.png)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2024 By upupming</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>