<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Speedy SSR 功能的实现原理和经验总结"><meta name="keywords" content="frontend"><meta name="author" content="upupming"><meta name="copyright" content="upupming"><title>Speedy SSR 功能的实现原理和经验总结 | upupming 的博客</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.6.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="manifest" href="/manifest.json"><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#1B9EF3"><meta name="msapplication-TileColor" content="#1B9EF3"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#1B9EF3"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-2188191456032650',
  enable_page_level_ads: 'true'
});
</script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?295ad5c5a196e4964e20f74260711177";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-114899088-1', 'auto');
ga('send', 'pageview');</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"5WEDOKLFCL","apiKey":"26a57bfa5275b7c98a3b3ab7dae61915","indexName":"upupming-blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是服务端渲染"><span class="toc-number">1.</span> <span class="toc-text"> 什么是服务端渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#speedy-中服务端渲染的实现"><span class="toc-number">2.</span> <span class="toc-text"> Speedy 中服务端渲染的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bundler-实现"><span class="toc-number">2.1.</span> <span class="toc-text"> Bundler 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#server-实现"><span class="toc-number">2.2.</span> <span class="toc-text"> Server 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#adapter-实现"><span class="toc-number">2.3.</span> <span class="toc-text"> Adapter 实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结与思考"><span class="toc-number">3.</span> <span class="toc-text"> 总结与思考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">4.</span> <span class="toc-text"> 参考资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/doraemon.jpeg"></div><div class="author-info__name text-center">upupming</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">52</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">44</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">27</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" href="https://molunerfinn.com/">MARKSZのBlog</a><a class="author-info-links__name text-center" href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md">提问的智慧</a><a class="author-info-links__name text-center" href="https://zh.wikipedia.org/">中文维基百科</a><a class="author-info-links__name text-center" href="https://zbqtesla.github.io">ZBQTesla的博客</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/background.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">upupming 的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="https://mirror.upupming.site">Mirror</a><a class="site-page" href="https://music.wxhbts.com">音乐</a><a class="site-page" href="https://writing.upupming.site">Writing</a><a class="site-page" href="/about">关于</a><a class="site-page" href="/rss">RSS</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">Speedy SSR 功能的实现原理和经验总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-05-21</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/前端/">前端</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/前端/基础知识/">基础知识</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">5.2k</span><span class="post-meta__separator">|</span><span>阅读时长: 24 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><!--
是个啥
有啥用
技术难点
趋势
 -->
<p>在 2022 年，字节实习的那段时间里，我参与了 Speedy 的开发，主要的任务是为 Speedy 实现服务端渲染的能力，本文介绍一下实现原理。</p>
<p><img src="https://s2.loli.net/2023/05/21/h6rf7PRjOlKEZHA.png" alt="20230521221623"></p>
<a id="more"></a>
<h2 id="什么是服务端渲染"><a class="markdownIt-Anchor" href="#什么是服务端渲染"></a> 什么是服务端渲染</h2>
<p>服务端渲染（Server Side Rendering, SSR），就是指从服务端渲染出前端页面的内容。在以往早期的时候，前后端还没有分离，网页内容完全是由服务端渲染的，例如用 PHP 做后端生成好网页内容之后返回给前端负责显示，我了解到还有 JSP (Java Server Pages), <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> (Active Server Pages Network Enabled Technologies) 等。但是随着前端越来越复杂，前后端开始分离，逐渐出现了各种前端框架，如 React (2013), Vue (2014), Angular (2016), Svelte (2016) 等等。前后端开始分工明确，客户端渲染（Client Side Rendering, CSR）大行其道，这种模式下面所有页面内容都由客户端动态渲染而来。</p>
<p>纯的客户端渲染主要有两个问题:</p>
<ol>
<li>拿到前端页面代码之后，一般页面往往需要从后端获取数据才能展示页面，导致白屏时间长。</li>
<li>SEO 不友好，搜索引擎拿到页面之后往往不会继续请求数据，这样抓取到的页面可能会是只带 JS 文件的空白 HTML。</li>
</ol>
<p>这样 SSR 又逐渐流行起来，以弥补 CSR 的缺点。SSR 主要的方法是前端框架实现一套服务端渲染的 API，支持对组件进行脱水（hydrate）和水合（de-hydrate）。服务端（Node.js）负责将前端组件进行脱水得到 HTML 内容，这样浏览器请求之后的页面是有内容的，不用再重复请求数据；浏览器拿到数据和 HTML 之后进行水合，继续以前端组件的形式完成渲染，支持前端组件的生命周期和对应的 API。这样 CSR 和 SSR 的优点就结合了起来，使得开发体验更好的同时首屏得以保证，当然需要维护额外的 Node.js 服务器，以及构建工具需要对服务端渲染做一些支持，这是额外的成本投入，这也是我这次要讲的内容~</p>
<h2 id="speedy-中服务端渲染的实现"><a class="markdownIt-Anchor" href="#speedy-中服务端渲染的实现"></a> Speedy 中服务端渲染的实现</h2>
<p><a href="https://github.com/upupming/speedy-ssr-examples" target="_blank" rel="noopener">https://github.com/upupming/speedy-ssr-examples</a> 给出了 Speedy 的 SSR 的一些 DEMO。以 <a href="https://github.com/upupming/speedy-ssr-examples/tree/main/examples/basic" target="_blank" rel="noopener"><code>basic</code></a> 项目为例，在 <code>speedy.config.ts</code> 中定义了四个路由，分别解释如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  ssr: &#123;</span><br><span class="line">    pages: [</span><br><span class="line">      <span class="comment">// SSG 路由</span></span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'/ssg'</span>,</span><br><span class="line">        name: <span class="string">'ssg'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// SSR 路由</span></span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'/ssr'</span>,</span><br><span class="line">        name: <span class="string">'ssr'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 没有服务端渲染的纯静态页面</span></span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'/static'</span>,</span><br><span class="line">        name: <span class="string">'static'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 支持参数的页面</span></span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'/params/:id/:name'</span>,</span><br><span class="line">        name: <span class="string">'params'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>name</code> 就是代码所处的文件夹，<code>path</code> 是最终产物的 URL 路径。每一个页面的组织形式都是文件夹包含两个文件 <code>index.tsx</code> 和 <code>prefetch.ts</code> 形式，其中 <code>index.tsx</code> 是页面组件，<code>prefetch</code> 是数据预取函数。我们借鉴了 Next.js 的思路，根据 <code>prefetch</code> 中导出的函数名确定当前页面是 SSR 还是 SSG (Server Side Generating, 服务端生成)。与 SSR 不同，SSG 只在构建的时候生成一次数据，然后在前端访问时每次都获取构建时的数据，这种比较适用于构建时内容就确定了的页面，例如个人博客。</p>
<p><code>prefetch</code> 中的数据会作为 <code>props</code> 喂给 <code>index.tsx</code> 中的组件，然后渲染成当前页面，主要用来解决首屏数据请求耗时造成白屏的问题，要求导出的函数名称必须为 <code>getStaticProps</code> 或者 <code>getServerSideProps</code>，前者是 SSG，后者是 SSR。</p>
<p>以 <code>/ssr</code> 页面为例，后端会直接返回带内容的 HTML，并且将 <code>prefetch</code> 中预取到的数据挂在全局变量 <code>__CONTEXT__.routeData</code> 之下，以供前端继续水合，将 HTML 变成绑定了事件和生命周期的 React 组件。</p>
<p><img src="https://s2.loli.net/2023/05/21/a4HzbSqZ1K7VoBx.png" alt="20230521194101"><br>
<img src="https://s2.loli.net/2023/05/21/7UlhG8MIa9PzZ1T.png" alt="20230521194138"></p>
<p>我们使用 <code>@speedy-js/universal</code> 包来支持 SSR，其封装了 <code>@speedy-js/core</code>，在其基础上增加了 SSR 和 SSG 的能力。<code>@speedy-js/universal</code> 的主要贡献有:</p>
<ul>
<li>实现了一个 <code>BaseBundler</code> 类，包含 <code>serverBundler</code> 和 <code>clientBundler</code>。实现了 <code>ReactBundler</code> 来实现对 React 框架代码的编译，用户可以通过配置 <code>ssr.framework</code> 来配置当前使用的框架。
<ul>
<li>在 Speedy 中存在子编译器的概念，也是借鉴于 Webpack，我们通过将 <code>serverBundler</code> 作为 <code>clientBundler</code> 的子编译器，这样在开发模式下只有一个 watcher，代码发生修改时，<code>clientBundler</code> 会通知 <code>serverBundler</code>。</li>
<li><code>serverBundler</code> 负责编译服务端代码，产物是 CJS 格式。编译产物代码存在两个导出函数，分别是 <code>Component</code> 和 <code>getServerSideProps</code>，其中 <code>Component</code> 是服务端代码的 React 组件，<code>getServerSideProps</code> 是对应的 <code>prefetch.ts</code> 中的数据预取函数。
<ul>
<li>脱水逻辑已经封装在 bundler 内部，后面的 Server 会负责将 <code>Component</code> 脱水并处理前端请求。</li>
</ul>
</li>
<li><code>clientBundler</code> 负责编译客户端代码，产物是 SystemJS 格式（利用 SystemJS 支持分包）。同样包含两个导出，分别是 <code>default</code> 和 <code>getServerSideProps</code>。<code>default</code> 是客户端代码的 React 组件，<code>getServerSideProps</code> 是对应的 <code>prefetch.ts</code> 中的数据预取函数。<code>getServerSideProps</code> 在客户端代码中仍然存在是为了进行 CSR 降级，在服务端挂掉时仍然能够进行数据请求。
<ul>
<li>只靠这两个导出，无法页面正常运行，因此我们的 Server 还会增加 JS 文件，利用这两个导出，在对应的时机进行水合，使页面正常工作。</li>
</ul>
</li>
</ul>
</li>
<li>实现了一个 <code>BaseServer</code> 类，可以通过 <code>createServer</code> 函数来创建其子类 <code>DevServer</code>（功能类似 <code>vite dev</code>） 或者 <code>ProdServer</code>（功能类似 <code>vite preview</code>）,其返回结果类似于 <a href="https://github.com/vercel/next.js/blob/cfa8ab9cbfb8818408654e223aa9253be619879e/packages/next/server/next.ts#L25" target="_blank" rel="noopener">NextServer</a>, 使用例子参考 <a href="https://nextjs.org/docs/advanced-features/custom-server" target="_blank" rel="noopener">Next.js | Custom Server</a>。并且与之对应有一个 <code>createHttpServer</code> 函数来创建 Server 的同时绑定到端口让前端直接访问。
<ul>
<li>采用了 Connect 中间件实现内部的请求处理逻辑，方便拓展和复用。</li>
</ul>
</li>
<li>支持了不同的 Adapter，来实现将产物部署到不同的 Serverless 环境。支持了 Vercel 和 Cloudflare Worker。</li>
</ul>
<h3 id="bundler-实现"><a class="markdownIt-Anchor" href="#bundler-实现"></a> Bundler 实现</h3>
<p><code>BaseBundler</code> 包含一些通用逻辑，具体不同框架的实现由对应的子类去实现，我们可以抽象出一些 Bundler 需要做的事情：</p>
<ul>
<li>包含 <code>clientBundler</code> 和 <code>serverBundler</code> 分别编译客户端代码和服务端代码。</li>
<li>在构建时进行 SSG 生成，调用对应语言的 <code>SSGRunner</code> 来生成 JSON 数据到产物中。</li>
</ul>
<p><code>ReactBundler</code> 包含具体的实现，下面是初始化 <code>clientBundler</code> 和 <code>serverBundler</code> 的逻辑：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.clientBundler = <span class="keyword">await</span> SpeedyBundler.create(</span><br><span class="line">  &#123;</span><br><span class="line">    ...config,</span><br><span class="line">    target: <span class="string">'es6'</span>,</span><br><span class="line">    root,</span><br><span class="line">    mode: dev ? <span class="string">'development'</span> : <span class="string">'production'</span>,</span><br><span class="line">    input: &#123;</span><br><span class="line">      <span class="comment">// Client-side-only entries</span></span><br><span class="line">      ...config?.input,</span><br><span class="line">      <span class="comment">// SSR client entries，我们对每个页面都生成了一个虚拟入口文件，这样能够对用户编写的文件进行 import，在用户代码的基础上做一些封装；virtual entry 的思路在构建工具中很常见</span></span><br><span class="line">      ...Object.fromEntries(appContext.normalizedPages.map(<span class="function">(<span class="params">&#123; name &#125;</span>) =&gt;</span> [name, getVirtualEntry(name)])),</span><br><span class="line">      <span class="comment">// virtual entry，这里的虚拟入口的代码也就是驱动客户端代码进行水合的那部分模板代码</span></span><br><span class="line">      <span class="comment">// VIRTUAL_ROOT_NAME === '__ROOT__'</span></span><br><span class="line">      [VIRTUAL_ROOT_NAME]: getVirtualEntry(VIRTUAL_ROOT_NAME),</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">      format: <span class="string">'system'</span>,</span><br><span class="line">      splitting: <span class="literal">true</span>,</span><br><span class="line">      ...config?.output,</span><br><span class="line">      path: OUTPUT_FOLDER,</span><br><span class="line">      entryNames: dev ? <span class="string">'client/[name]'</span> : <span class="string">'client/[name]-[hash]'</span>,</span><br><span class="line">      chunkNames: <span class="string">'client/[name].[hash]'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    define: &#123;</span><br><span class="line">      __BROWSER__: <span class="string">'true'</span>,</span><br><span class="line">      global: <span class="string">'globalThis'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    command: dev ? <span class="string">'serve'</span> : <span class="string">'build'</span>,</span><br><span class="line">    watch: dev,</span><br><span class="line">    configFile: <span class="literal">false</span>,</span><br><span class="line">    platform: <span class="string">'browser'</span>,</span><br><span class="line">    plugins: [</span><br><span class="line">      ...(config?.plugins ?? []),</span><br><span class="line">      resolvePlugin(&#123; root &#125;),</span><br><span class="line">      <span class="comment">// clientPlugin 里面包含了对 virtual entry 的处理逻辑和对应应该生成的代码。</span></span><br><span class="line">      clientPlugin(&#123;</span><br><span class="line">        appContext: <span class="keyword">this</span>.appContext,</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="comment">// 进度条插件，并行展示 Client 代码的进度条</span></span><br><span class="line">      progressPlugin(&#123; id: <span class="string">'Client'</span>, quietOnDev: <span class="literal">false</span> &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'universal.client'</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> serverPlatform = environment === <span class="string">'node'</span> ? <span class="string">'node'</span> : <span class="string">'browser'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.serverBundler = <span class="keyword">await</span> <span class="keyword">this</span>.clientBundler.createChildCompiler(</span><br><span class="line">  &#123;</span><br><span class="line">    ...config,</span><br><span class="line">    root,</span><br><span class="line">    input: <span class="built_in">Object</span>.fromEntries(appContext.normalizedPages.map(<span class="function">(<span class="params">&#123; name &#125;</span>) =&gt;</span> [name, getVirtualEntry(name)])),</span><br><span class="line">    output: &#123;</span><br><span class="line">      splitting: <span class="literal">true</span>,</span><br><span class="line">      ...config?.output,</span><br><span class="line">      format: <span class="string">'cjs'</span>,</span><br><span class="line">      path: OUTPUT_FOLDER,</span><br><span class="line">      entryNames: <span class="string">'server/[name]'</span>,</span><br><span class="line">      chunkNames: <span class="string">'server/[name].[hash]'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    html: <span class="literal">false</span>,</span><br><span class="line">    mode: dev ? <span class="string">'development'</span> : <span class="string">'production'</span>,</span><br><span class="line">    minify: <span class="literal">false</span>,</span><br><span class="line">    command: <span class="string">'build'</span>,</span><br><span class="line">    watch: dev,</span><br><span class="line">    configFile: <span class="literal">false</span>,</span><br><span class="line">    define: &#123;</span><br><span class="line">      __BROWSER__: <span class="string">'false'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    platform: serverPlatform,</span><br><span class="line">    plugins: [</span><br><span class="line">      ...(config?.plugins ?? []),</span><br><span class="line">      resolvePlugin(&#123; root, external: <span class="literal">true</span> &#125;),</span><br><span class="line">      externalPlugin(externalOptions),</span><br><span class="line">      <span class="comment">// serverPlugin 里面包含了对 virtual entry 的处理逻辑和对应应该生成的代码。</span></span><br><span class="line">      serverPlugin(&#123; root, appContext &#125;),</span><br><span class="line">      <span class="comment">// 进度条插件，并行展示 Server 代码的进度条</span></span><br><span class="line">      progressPlugin(&#123; id: <span class="string">'Server'</span>, quietOnDev: <span class="literal">false</span> &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'universal.server'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这里最核心的是对生成产物的代码的控制，其实现逻辑在 <code>clientPlugin</code> 中。Speedy 中插件均是通过 Tapable 的 hook 来实现了，也是借鉴了 Webpack 的插件体系。我们来看 <code>clientPlugin</code> 中比较核心的代码生成逻辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// packages/universal/src/bundler/react/plugins/virtual-entry/client.tsx</span><br><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">import &#123; Browser, loadRouteModules &#125; from &apos;@speedy-js/universal/components&apos;;</span><br><span class="line"></span><br><span class="line">async function init() &#123;</span><br><span class="line">  const data = JSON.parse(document.getElementById(&apos;__SPEEDY_DATA__&apos;)?.textContent ?? &apos;&#123;&#125;&apos;);</span><br><span class="line">  window.__SPEEDY__ = data;</span><br><span class="line"></span><br><span class="line">  const root = document.getElementById(&apos;root&apos;);</span><br><span class="line">  if (!root) &#123;</span><br><span class="line">    throw new Error(&apos;🔥 Hmm, cannot find `#root` to mount the component.&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (!data.__SSR__) &#123;</span><br><span class="line">    ReactDOM.render(&lt;Browser /&gt;, root);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    const &#123; assetsMeta, matchedPage &#125; = data.__CONTEXT__;</span><br><span class="line"></span><br><span class="line">    const &#123; assets, module &#125; = assetsMeta[matchedPage.name];</span><br><span class="line">    const routeModule = await loadRouteModules(assets, module, matchedPage.name);</span><br><span class="line">    data.__CONTEXT__.routeModules[matchedPage.name] = routeModule;</span><br><span class="line"></span><br><span class="line">    ReactDOM.hydrate(&lt;Browser /&gt;, root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  window.__SPEEDY_APP_LOADED__ = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> clientVirtualEntryCode <span class="keyword">from</span> <span class="string">'./virtual-entry/client?raw'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> clientPlugin = (&#123; appContext &#125;: &#123; appContext: AppContext &#125;): <span class="function"><span class="params">SpeedyPlugin</span> =&gt;</span> &#123;</span><br><span class="line">  compiler.hooks.load.tapPromise(CLIENT_PLUGIN_NAME, <span class="keyword">async</span> (args) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">new</span> <span class="built_in">RegExp</span>(VIRTUAL_ENTRY_SUFFIX).test(args.path)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; query &#125; = resolvePathAndQuery(args.path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> pageName = query[QUERY_PAGE_NAME];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pageName) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pageName === VIRTUAL_ROOT_NAME) &#123;</span><br><span class="line">      <span class="comment">// 把模板代码作为字符串返回给 speedy 进行编译，实现了对用户代码的封装</span></span><br><span class="line">      <span class="keyword">const</span> entryHelper = <span class="keyword">new</span> EntryHelper(clientVirtualEntryCode);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        loader: <span class="string">'tsx'</span>,</span><br><span class="line">        resolveDir: root,</span><br><span class="line">        contents: entryHelper.toString(),</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> page = appContext.getPageByName(pageName)!;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> prefetchPath = page.prefetch;</span><br><span class="line">    <span class="keyword">const</span> relativePrefetchPath = prefetchPath &amp;&amp; path.relative(root, prefetchPath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> entryPath = page.entry;</span><br><span class="line">    <span class="keyword">const</span> relativeEntryPath = path.relative(root, entryPath);</span><br><span class="line">    <span class="keyword">const</span> entryHelper = <span class="keyword">new</span> EntryHelper(<span class="string">`export &#123; default &#125; from './<span class="subst">$&#123;relativeEntryPath&#125;</span>'`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prefetchPath &amp;&amp; fs.existsSync(prefetchPath)) &#123;</span><br><span class="line">      <span class="keyword">const</span> entryPoints: Record&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; = &#123;</span><br><span class="line">        prefetch: prefetchPath,</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">const</span> buildResult = esbuild.buildSync(&#123;</span><br><span class="line">        absWorkingDir: root,</span><br><span class="line">        entryPoints,</span><br><span class="line">        outdir: root,</span><br><span class="line">        metafile: <span class="literal">true</span>,</span><br><span class="line">        write: <span class="literal">false</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">const</span> prefetchExportedNames = buildResult.metafile?.outputs?.[<span class="string">'prefetch.js'</span>]?.exports;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> isSSG = prefetchExportedNames?.includes(<span class="string">'getStaticProps'</span>);</span><br><span class="line">      <span class="keyword">const</span> isSSR = prefetchExportedNames?.includes(<span class="string">'default'</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isSSG) &#123;</span><br><span class="line">        prefetchTypeMap[pageName] = PREFETCH_TYPE.SSG;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isSSR) &#123;</span><br><span class="line">        prefetchTypeMap[pageName] = PREFETCH_TYPE.SSR;</span><br><span class="line"></span><br><span class="line">        entryHelper.addReExport(&#123;</span><br><span class="line">          exportName: <span class="string">'default as getServerSideProps'</span>,</span><br><span class="line">          filepath: <span class="string">`./<span class="subst">$&#123;relativePrefetchPath&#125;</span>`</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      loader: <span class="string">'tsx'</span>,</span><br><span class="line">      resolveDir: root,</span><br><span class="line">      contents: entryHelper.toString(),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是 <code>basic</code> 为例子生成的 <code>__ROOT__.js</code> 和 <code>client/ssr.js</code> 的简化版本:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// __ROOT__.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 水合逻辑</span></span><br><span class="line">init()</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React 组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br><span class="line"><span class="comment">// 数据预取函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getServerSideProps</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>另外 <code>clientPlugin</code> 在后处理 HTML 文件的时候，会加入一些元信息（manifest），后续可供使用：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">compiler.hooks.processAssets.tapPromise(</span><br><span class="line">  &#123;</span><br><span class="line">    name: CLIENT_PLUGIN_NAME,</span><br><span class="line">    stage: compiler.STAGE.PROCESS_ASSETS_MODIFY_GENERATED_HTML,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> (bundles, manifest) =&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> [chunkName, chunk] of compiler.outputChunk.entries()) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// Append root.js to all html outputs</span></span><br><span class="line">      <span class="keyword">if</span> (chunkName.endsWith(<span class="string">'.html'</span>)) &#123;</span><br><span class="line">        <span class="comment">// add manifest to all pages</span></span><br><span class="line">        chunk.contents = chunk.contents.toString().replace(</span><br><span class="line">          <span class="string">'&lt;/body&gt;'</span>,</span><br><span class="line">          <span class="string">`</span></span><br><span class="line"><span class="string">          &lt;script id="<span class="subst">$&#123;__SPEEDY_DATA_ID__&#125;</span>" type="application/json"&gt;</span></span><br><span class="line"><span class="string">          <span class="subst">$&#123;serializeState&lt;SpeedyData&gt;(&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">            __CONTEXT__: &#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">              basename: ssrOptions.baseUrl,</span></span></span><br><span class="line"><span class="string"><span class="subst">              matchedPage,</span></span></span><br><span class="line"><span class="string"><span class="subst">              pages: ssrOptions.pages,</span></span></span><br><span class="line"><span class="string"><span class="subst">              isModule,</span></span></span><br><span class="line"><span class="string"><span class="subst">              assetsMeta,</span></span></span><br><span class="line"><span class="string"><span class="subst">              routeData: &#123;&#125;</span>,</span></span><br><span class="line"><span class="string">              routeModules: &#123;&#125;,</span></span><br><span class="line"><span class="string">              getServerDataMeta: &#123;&#125;,</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            __SSR__: false,</span></span><br><span class="line"><span class="string">          &#125;)&#125;</span></span><br><span class="line"><span class="string">          &lt;/script&gt;</span></span><br><span class="line"><span class="string">          &lt;/body&gt;</span></span><br><span class="line"><span class="string">          `</span>.trim()</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>再来看 <code>serverPlugin</code> 的核心代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// packages/universal/src/bundler/react/plugins/virtual-entry/server.tsx</span><br><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import &#123; Server &#125; from &apos;@speedy-js/universal/components&apos;;</span><br><span class="line">import type &#123; ServerSideRenderContext &#125; from &apos;@speedy-js/universal/interface&apos;;</span><br><span class="line">// @ts-ignore, __ENTRY_PATH__ 要被替换为实际的路径才能实现封装</span><br><span class="line">import Entry from &apos;__ENTRY_PATH__&apos;;</span><br><span class="line"></span><br><span class="line">export const Component: React.FC&lt;ServerSideRenderContext&gt; = (props) =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Server &#123;...props&#125;&gt;</span><br><span class="line">      &lt;Entry /&gt;</span><br><span class="line">    &lt;/Server&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> serverVirtualEntryCode <span class="keyword">from</span> <span class="string">'./virtual-entry/server?raw'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> serverPlugin = (&#123; appContext, root &#125;: ServerPluginOptions): <span class="function"><span class="params">SpeedyPlugin</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: SERVER_PLUGIN_NAME,</span><br><span class="line">    apply(compiler) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      compiler.hooks.load.tapPromise(SERVER_PLUGIN_NAME, <span class="keyword">async</span> (args) =&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">new</span> <span class="built_in">RegExp</span>(VIRTUAL_ENTRY_SUFFIX).test(args.path)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> &#123; query &#125; = resolvePathAndQuery(args.path);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> pageName = query[QUERY_PAGE_NAME];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pageName) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> page = appContext.getPageByName(pageName)!;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> entryPath = page.entry;</span><br><span class="line">        <span class="keyword">const</span> prefetchPath = page.prefetch;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> entryPoints: Record&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; = &#123;</span><br><span class="line">          server: entryPath,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prefetchPath) &#123;</span><br><span class="line">          entryPoints.prefetch = prefetchPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> buildResult = esbuild.buildSync(&#123;</span><br><span class="line">          absWorkingDir: root,</span><br><span class="line">          entryPoints,</span><br><span class="line">          outdir: root,</span><br><span class="line">          metafile: <span class="literal">true</span>,</span><br><span class="line">          write: <span class="literal">false</span>,</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> entryExportedNames = buildResult.metafile?.outputs[<span class="string">'server.js'</span>].exports;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> relativeEntryPath = path.relative(root, entryPath);</span><br><span class="line">        <span class="keyword">if</span> (!entryExportedNames?.includes(<span class="string">'default'</span>)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`The component should be exported by default, file: <span class="subst">$&#123;relativeEntryPath&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> prefetchExportedNames = buildResult.metafile?.outputs?.[<span class="string">'prefetch.js'</span>]?.exports;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> hasPrefetch = !!prefetchExportedNames;</span><br><span class="line">        <span class="keyword">const</span> isSSG = prefetchExportedNames?.includes(<span class="string">'getStaticProps'</span>);</span><br><span class="line">        <span class="keyword">const</span> isSSR = prefetchExportedNames?.includes(<span class="string">'default'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> relativePrefetchPath = prefetchPath &amp;&amp; path.relative(root, prefetchPath);</span><br><span class="line">        <span class="keyword">if</span> (hasPrefetch) &#123;</span><br><span class="line">          <span class="keyword">if</span> (isSSG &amp;&amp; isSSR) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">              <span class="string">`Cannot export both 'getStaticProps' and 'default' at the same time in prefetch entry, please remove one of them, file: <span class="subst">$&#123;relativePrefetchPath&#125;</span>`</span></span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (!isSSG &amp;&amp; !isSSR &amp;&amp; prefetchExportedNames) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">              <span class="string">`Should export one of 'getStaticProps' or 'default' in prefetch entry, file: <span class="subst">$&#123;relativePrefetchPath&#125;</span>`</span></span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> entryHelper = <span class="keyword">new</span> EntryHelper(serverVirtualEntryCode);</span><br><span class="line"></span><br><span class="line">        entryHelper.replace(__ENTRY_PATH__, <span class="string">`./<span class="subst">$&#123;relativeEntryPath&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">if</span> (hasPrefetch) &#123;</span><br><span class="line">          entryHelper.addReExport(&#123;</span><br><span class="line">            exportName: isSSR ? <span class="string">'default as getServerSideProps'</span> : <span class="string">'getStaticProps'</span>,</span><br><span class="line">            filepath: <span class="string">`./<span class="subst">$&#123;relativePrefetchPath&#125;</span>`</span>,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          loader: <span class="string">'tsx'</span>,</span><br><span class="line">          resolveDir: root,</span><br><span class="line">          contents: entryHelper.toString(),</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>
<p>下面是 <code>basic</code> 为例子生成的 <code>server/ssr.js</code> 的简化版本:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server/ssr.js</span></span><br><span class="line"><span class="comment">// React 组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 数据预取函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getServerSideProps</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="server-实现"><a class="markdownIt-Anchor" href="#server-实现"></a> Server 实现</h3>
<p><code>BaseServer</code> 中也是包含了一些通用逻辑，开发模式和生产模式分别实现子类。通用逻辑有：</p>
<ul>
<li>
<p>初始化一些 Polyfill ，这些 Polyfill 用于 Node.js 中运行一些浏览器常用的 API，例如 <code>atob</code>, <code>btoa</code>, fetch API 的 <code>Headers</code>, <code>Request</code> 和 <code>Response</code> 等，参考了 remix-node 进行实现。</p>
</li>
<li>
<p>定义一个 Connect 实例 <code>middlewares</code>，负责串联服务器的所有逻辑，用户可以通过向 <code>middlewares</code> 中 <code>push</code> 新的处理函数来自定义服务器的行为。</p>
</li>
<li>
<p><code>prepare</code> 函数，供 Server 内部执行一些异步函数，确保异步函数执行完之后再调用 Server 的具体方法。</p>
</li>
<li>
<p><code>handleStatic</code> 处理静态资源的逻辑。</p>
</li>
<li>
<p><code>handleServerSideRequest</code> 处理服务端请求。包含 SSR 请求时，服务端的逻辑，会执行 server 产物中的数据预取函数并完成脱水流程。</p>
  <figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">abstract</span> <span class="keyword">class</span> BaseServer &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  handleServerSideRequest = <span class="keyword">async</span> (req: IncomingMessage, res: ServerResponse) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; framework, pages, baseUrl &#125; = <span class="keyword">this</span>.ssrOptions;</span><br><span class="line">      <span class="keyword">const</span> &#123; dev, root &#125; = <span class="keyword">this</span>.options;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!req.url) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> url = <span class="keyword">new</span> URL(req.url, <span class="string">`http://<span class="subst">$&#123;req.headers.host&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> matchedPage = matchPage(&#123;</span><br><span class="line">        pages,</span><br><span class="line">        pathname: url.pathname,</span><br><span class="line">        baseUrl,</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> &#123; prefetchTypeMap &#125; = <span class="keyword">this</span>.manifest;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (matchedPage?.name) &#123;</span><br><span class="line">        <span class="comment">// production, serve page as static files</span></span><br><span class="line">        <span class="keyword">if</span> (prefetchTypeMap[matchedPage.name] === PREFETCH_TYPE.SSG &amp;&amp; !dev) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> template = fs.readFileSync(getHtmlPath(<span class="keyword">this</span>.dist, matchedPage.name), <span class="string">'utf-8'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (url.searchParams.has(<span class="string">'csr'</span>)) &#123;</span><br><span class="line">          <span class="keyword">return</span> res.end(template);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// should not cache html files in browser</span></span><br><span class="line">        <span class="comment">// https://nextjs.org/docs/going-to-production#caching</span></span><br><span class="line">        res.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'no-cache, no-store, max-age=0, must-revalidate'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (framework === <span class="string">'react'</span>) &#123;</span><br><span class="line">          <span class="comment">// Renderer 内部会根据当前请求页面是 SSR 还是 SSG 去进行不同的渲染逻辑；可以直接根据构建产物的 export 名称来判断</span></span><br><span class="line">          <span class="keyword">const</span> renderer = <span class="keyword">new</span> Renderer(&#123;</span><br><span class="line">            baseUrl,</span><br><span class="line">            dist: <span class="keyword">this</span>.dist,</span><br><span class="line">            matchedPage,</span><br><span class="line">            name: matchedPage.name,</span><br><span class="line">            template,</span><br><span class="line">            pages,</span><br><span class="line">            root,</span><br><span class="line">            dev,</span><br><span class="line">            pageMeta: <span class="keyword">this</span>.manifest.entryMeta[matchedPage.name],</span><br><span class="line">            assetsMeta: <span class="keyword">this</span>.manifest.assetsMeta ?? &#123;&#125;,</span><br><span class="line">            isModule: <span class="keyword">this</span>.manifest.format === <span class="string">'esm'</span>,</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="comment">// 借鉴了 Remix 的思想，将所有请求转化为 fetch API req/res 来进行处理，renderer 只需考虑 fetch API 即可</span></span><br><span class="line">          <span class="keyword">const</span> response = <span class="keyword">await</span> withFetchAPI(req, res, <span class="keyword">async</span> (request) =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> renderer.render(request);</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`universal server for framework <span class="subst">$&#123;framework&#125;</span> has not been implemented`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>DevServer</code> 需要增加 <code>handleStatic</code> 函数的逻辑，由于 Speedy 内部已经实现了对静态资源的 server，直接对其进行代理即可：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> DevServer &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  handleRequest: SimpleHandleFunction = <span class="keyword">async</span> (req: IncomingMessage, res: ServerResponse) =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.setHttpProxyHandler(req);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> resp = <span class="keyword">await</span> <span class="keyword">this</span>.handleServerSideRequest(req, res);</span><br><span class="line">        <span class="keyword">if</span> (resp) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (path.parse(req.url ?? <span class="string">'/'</span>).ext) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.handleStatic(req, res);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> res.end(renderNotFound());</span><br><span class="line">    &#125;;</span><br><span class="line">  handleStatic: SimpleHandleFunction = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> httpProxy = <span class="keyword">this</span>.getHttpProxy();</span><br><span class="line">    <span class="comment">// https://nextjs.org/docs/going-to-production#caching</span></span><br><span class="line">    res.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'no-cache, no-store, max-age=0, must-revalidate'</span>);</span><br><span class="line">    httpProxy.web(req, res);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>ProdServer</code>，则有不同的 <code>handleStatic</code> 逻辑，从产物中进行 serve:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">handleStatic: Connect.SimpleHandleFunction = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; url: reqUrl = <span class="string">''</span> &#125; = req;</span><br><span class="line">  <span class="keyword">const</span> publicPath = getPublicPath(<span class="keyword">this</span>.manifest.publicPath);</span><br><span class="line">  <span class="keyword">const</span> &#123; baseUrl &#125; = <span class="keyword">this</span>.ssrOptions;</span><br><span class="line">  <span class="keyword">const</span> name = reqUrl</span><br><span class="line">    .split(<span class="string">'?'</span>)[<span class="number">0</span>]</span><br><span class="line">    .replace(<span class="regexp">/.html?$/</span>, <span class="string">''</span>)</span><br><span class="line">    .replace(baseUrl, <span class="string">''</span>)</span><br><span class="line">    .slice(baseUrl === <span class="string">'/'</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> filename = getFilenameFromUrl(<span class="string">`/<span class="subst">$&#123;name ?? <span class="string">''</span>&#125;</span>`</span>, [</span><br><span class="line">    &#123;</span><br><span class="line">      publicPath,</span><br><span class="line">      outputPath: <span class="keyword">this</span>.dist,</span><br><span class="line">    &#125;,</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!filename || !fs.existsSync(filename) || fs.lstatSync(filename).isDirectory()) &#123;</span><br><span class="line">    res.statusCode = <span class="number">404</span>;</span><br><span class="line">    res.end(<span class="string">'Page Not Found'</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> reqPath = <span class="built_in">decodeURI</span>(url.parse(reqUrl).pathname || <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> mimeType = lookup(reqPath) || lookup(filename);</span><br><span class="line">  <span class="keyword">if</span> (mimeType) &#123;</span><br><span class="line">    res.setHeader(<span class="string">'Content-Type'</span>, mimeType);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  res.statusCode = <span class="number">200</span>;</span><br><span class="line">  <span class="comment">// https://developers.google.com/web/fundamentals/performance/webpack/use-long-term-caching</span></span><br><span class="line">  <span class="comment">// https://nextjs.org/docs/going-to-production#caching</span></span><br><span class="line">  res.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'public, max-age=31536000, immutable'</span>);</span><br><span class="line">  fs.createReadStream(filename).pipe(res);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后我们实现了 <code>universal</code> 这个脚本，添加 <code>universal dev</code> 和 <code>universal build</code> 分别来进行开发和构建，可以用 <code>universal start</code> 来启动 <code>ProdServer</code>。</p>
<h3 id="adapter-实现"><a class="markdownIt-Anchor" href="#adapter-实现"></a> Adapter 实现</h3>
<p>为了让我们的代码不仅能在 Node.js 环境下面通过 <code>universal</code> CLI 来部署，还想在 Vercel 和 CloudFlare 以及公司内的其他 Serverless 或者 Edge 上部署，我们参考了 <a href="https://remix.run/docs/en/main/other-api/adapter" target="_blank" rel="noopener">Remix Adapter</a> 的思想来支持不同的适配器，实现不同环境部署。</p>
<p>例如 Vercel Adapter 实现如下:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages/universal/src/adapters/vercel/index.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; IncomingMessage, ServerResponse &#125; <span class="keyword">from</span> <span class="string">'http'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ProdServer &#125; <span class="keyword">from</span> <span class="string">'../../server/prod-server'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> VercelAdapterOptions &#123;</span><br><span class="line">  root?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createVercelHandler</span>(<span class="params">&#123; root = process.cwd() &#125;: VercelAdapterOptions = &#123;&#125;</span>): (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  req: IncomingMessage,</span></span></span><br><span class="line"><span class="function"><span class="params">  res: ServerResponse</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) =&gt; <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> server = <span class="keyword">new</span> ProdServer(&#123; root &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> (req: IncomingMessage, res: ServerResponse) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> server.prepare();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handler = server.getRequestHandler();</span><br><span class="line">    <span class="keyword">return</span> handler(req, res);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在项目根目录创建 <code>server.vercel.js</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.vercel.js</span></span><br><span class="line"><span class="comment">// @ts-check</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; createVercelHandler &#125; = <span class="built_in">require</span>(<span class="string">'@speedy-js/universal/adapters/vercel'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = createVercelHandler();</span><br></pre></td></tr></table></figure>
<p><code>vercel.json</code>:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"version"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"public"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"github"</span>: &#123;</span><br><span class="line">    <span class="attr">"enabled"</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"builds"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"./server.vercel.js"</span>,</span><br><span class="line">      <span class="attr">"use"</span>: <span class="string">"@vercel/node"</span>,</span><br><span class="line">      <span class="attr">"config"</span>: &#123;</span><br><span class="line">        <span class="attr">"//"</span>: <span class="string">"https://github.com/vercel/vercel/issues/1788#issuecomment-485629244"</span>,</span><br><span class="line">        <span class="attr">"includeFiles"</span>: [<span class="string">"./.universal/**"</span>],</span><br><span class="line">        <span class="attr">"bundle"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"maxLambdaSize"</span>: <span class="string">"50mb"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"routes"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"/(.*)"</span>,</span><br><span class="line">      <span class="attr">"dest"</span>: <span class="string">"/server.vercel.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 <code>vercel --prod</code> 即可部署到 Vercel。</p>
<hr>
<p>CF Worker 的 Adapter 实现也很简单:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference lib="dom.iterable"/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; getAssetFromKV, MethodNotAllowedError, NotFoundError &#125; <span class="keyword">from</span> <span class="string">'@cloudflare/kv-asset-handler'</span>;</span><br><span class="line"><span class="keyword">import</span> type &#123; CloudflareBuildManifest &#125; <span class="keyword">from</span> <span class="string">'./interface'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; PREFETCH_TYPE &#125; <span class="keyword">from</span> <span class="string">'../../interface'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; renderToHTML &#125; <span class="keyword">from</span> <span class="string">'../../helpers/render'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; getQuery &#125; <span class="keyword">from</span> <span class="string">'../../helpers/getQuery'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; matchPage, PageMatch &#125; <span class="keyword">from</span> <span class="string">'../../helpers/matchPage'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FetchEvent &#125; <span class="keyword">from</span> <span class="string">'../../../client'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./interface'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface CloudflareWorkerAdapterOptions &#123;</span><br><span class="line">  dev?: boolean;</span><br><span class="line">  root?: string;</span><br><span class="line">  manifest: CloudflareBuildManifest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface CloudflareWorkerServerOptions extends CloudflareWorkerAdapterOptions &#123;</span><br><span class="line">  event: FetchEvent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloudflareWorkerServer</span> </span>&#123;</span><br><span class="line">  options: CloudflareWorkerServerOptions;</span><br><span class="line"></span><br><span class="line">  pathname: string;</span><br><span class="line"></span><br><span class="line">  origin: string;</span><br><span class="line"></span><br><span class="line">  url: URL;</span><br><span class="line"></span><br><span class="line">  matchedPage: PageMatch | <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(options: CloudflareWorkerServerOptions) &#123;</span><br><span class="line">    <span class="keyword">this</span>.options = options;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; event &#125; = <span class="keyword">this</span>.options;</span><br><span class="line">    <span class="keyword">this</span>.url = <span class="keyword">new</span> URL(event.request.url);</span><br><span class="line">    <span class="keyword">this</span>.pathname = <span class="keyword">this</span>.url.pathname;</span><br><span class="line">    <span class="keyword">this</span>.origin = <span class="keyword">this</span>.url.origin;</span><br><span class="line">    <span class="keyword">this</span>.matchedPage = <span class="keyword">this</span>.matchPageName(<span class="keyword">this</span>.pathname)!;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> handleAssets(): <span class="built_in">Promise</span>&lt;Response&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; pathname &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">await</span> getAssetFromKV(<span class="keyword">this</span>.options.event, &#123;</span><br><span class="line">        mapRequestToAsset: <span class="function">(<span class="params">request</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 这里使用了 manifest 文件</span></span><br><span class="line">          <span class="keyword">const</span> &#123; baseUrl &#125; = <span class="keyword">this</span>.options.manifest.ssrOptions;</span><br><span class="line">          <span class="keyword">if</span> (pathname.startsWith(baseUrl)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.matchedPage?.name) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> Request(<span class="keyword">new</span> URL(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.matchedPage.name&#125;</span>.html`</span>, <span class="keyword">this</span>.origin).href);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Request(<span class="keyword">new</span> URL(pathname.replace(baseUrl, <span class="string">''</span>), <span class="keyword">this</span>.origin).href);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> request;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e <span class="keyword">instanceof</span> NotFoundError) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Response(<span class="string">'NotFoundError'</span>, &#123; <span class="attr">status</span>: <span class="number">404</span> &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (e <span class="keyword">instanceof</span> MethodNotAllowedError) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Response(<span class="string">'MethodNotAllowedError'</span>, &#123; <span class="attr">status</span>: <span class="number">500</span> &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Response(<span class="string">'An unexpected error occurred'</span>, &#123; <span class="attr">status</span>: <span class="number">500</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> getAsset(url: string): <span class="built_in">Promise</span>&lt;string&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> getAssetFromKV(&#123;</span><br><span class="line">      request: <span class="keyword">new</span> Request(<span class="keyword">new</span> URL(url, <span class="keyword">this</span>.origin).href),</span><br><span class="line">      waitUntil: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res.text();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> handleSSRRequest(): <span class="built_in">Promise</span>&lt;Response&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      manifest,</span><br><span class="line">      event: &#123; request &#125;,</span><br><span class="line">    &#125; = <span class="keyword">this</span>.options;</span><br><span class="line">    <span class="keyword">const</span> &#123; pathname, search &#125; = <span class="keyword">this</span>.url;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.matchedPage) <span class="keyword">return</span> <span class="keyword">new</span> Response(<span class="string">'No matched SSR page'</span>, &#123; <span class="attr">status</span>: <span class="number">404</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> templateHtmlPath = <span class="string">`/<span class="subst">$&#123;<span class="keyword">this</span>.matchedPage.name&#125;</span>.html`</span>;</span><br><span class="line">    <span class="keyword">const</span> template = <span class="keyword">await</span> <span class="keyword">this</span>.getAsset(templateHtmlPath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; Component, getServerSideProps &#125; = manifest.exportsMap[<span class="keyword">this</span>.matchedPage.name].server;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">new</span> Response();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> html = <span class="keyword">await</span> renderToHTML(&#123;</span><br><span class="line">        Component,</span><br><span class="line">        getServerSideProps,</span><br><span class="line">        assetsMeta: manifest.assetsMeta,</span><br><span class="line">        basename: manifest.ssrOptions.baseUrl,</span><br><span class="line">        template,</span><br><span class="line">        pages: manifest.ssrOptions.pages,</span><br><span class="line">        matchedPage: <span class="keyword">this</span>.matchedPage,</span><br><span class="line">        context: &#123;</span><br><span class="line">          request,</span><br><span class="line">          response,</span><br><span class="line">          pathname,</span><br><span class="line">          query: getQuery(search),</span><br><span class="line">        &#125;,</span><br><span class="line">        isModule: manifest.format === <span class="string">'esm'</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Response(html, &#123;</span><br><span class="line">        ...response,</span><br><span class="line">        headers: &#123; ...Object.fromEntries(response.headers.entries()), <span class="string">'Content-Type'</span>: <span class="string">'text/html'</span> &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err: any) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Error when calling render function of server file: <span class="subst">$&#123;templateHtmlPath&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  matchPageName(pathname: string) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; ssrOptions &#125; = <span class="keyword">this</span>.options.manifest;</span><br><span class="line">    <span class="keyword">const</span> match = matchPage(&#123; <span class="attr">pages</span>: ssrOptions.pages, pathname, <span class="attr">baseUrl</span>: ssrOptions.baseUrl &#125;);</span><br><span class="line">    <span class="keyword">return</span> match;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> handleRequest() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; request &#125; = <span class="keyword">this</span>.options.event;</span><br><span class="line">    <span class="keyword">const</span> &#123; ssrOptions, prefetchTypeMap, exportsMap &#125; = <span class="keyword">this</span>.options.manifest;</span><br><span class="line">    <span class="keyword">const</span> &#123; framework &#125; = ssrOptions;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; searchParams &#125; = <span class="keyword">this</span>.url;</span><br><span class="line">    <span class="keyword">if</span> (searchParams.get(<span class="string">'__data'</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.matchedPage) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Response(<span class="string">'No matched SSR page for data'</span>, &#123; <span class="attr">status</span>: <span class="number">404</span> &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> &#123; getServerSideProps &#125; = exportsMap[<span class="keyword">this</span>.matchedPage.name].server;</span><br><span class="line">      <span class="keyword">if</span> (!getServerSideProps) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Response(<span class="string">'No matched SSR export getServerSideProps for data'</span>, &#123; <span class="attr">status</span>: <span class="number">404</span> &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> response = <span class="keyword">new</span> Response();</span><br><span class="line">      <span class="keyword">const</span> data = <span class="keyword">await</span> getServerSideProps(&#123;</span><br><span class="line">        request,</span><br><span class="line">        response,</span><br><span class="line">        pathname: <span class="keyword">this</span>.pathname ?? <span class="string">'/'</span>,</span><br><span class="line">        query: searchParams,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Response(<span class="built_in">JSON</span>.stringify(data), &#123;</span><br><span class="line">        ...response,</span><br><span class="line">        headers: &#123;</span><br><span class="line">          ...Object.fromEntries(response.headers.entries()),</span><br><span class="line">          <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.matchedPage?.name) &#123;</span><br><span class="line">      <span class="keyword">if</span> (prefetchTypeMap[<span class="keyword">this</span>.matchedPage.name] === PREFETCH_TYPE.SSR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (framework === <span class="string">'react'</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.handleSSRRequest();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`universal server for framework <span class="subst">$&#123;framework&#125;</span> has not been implemented`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他情况的话是静态资源，使用 CF Worker 的 KV 存储处理，构建产物需要上传到 KV 存储</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.handleAssets();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给的是 fetchAPI Request，我们要返回 fetchAPI Response</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> proxy the web socket connection when developing</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createCloudflareWorkerHandler</span>(<span class="params">options: CloudflareWorkerAdapterOptions</span>): (<span class="params">event: FetchEvent</span>) =&gt; <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> server = <span class="keyword">new</span> CloudflareWorkerServer(&#123;</span><br><span class="line">      ...options,</span><br><span class="line">      event,</span><br><span class="line">    &#125;);</span><br><span class="line">    event.respondWith(server.handleRequest());</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中用到了 manifest 文件来实现导入对应页面的代码，manifest 是由 <code>clientPlugin</code> 生成的:</p>
<p><img src="https://s2.loli.net/2023/05/21/WAzLY2lEGQxvdft.png" alt="manifest"></p>
<p>配置 <code>wrangler.toml</code>:</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name</span> = <span class="string">"ssr-react-example"</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">"javascript"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">zone_id</span> = <span class="string">""</span></span><br><span class="line"><span class="attr">account_id</span> = <span class="string">""</span></span><br><span class="line"><span class="attr">route</span> = <span class="string">""</span></span><br><span class="line"><span class="attr">workers_dev</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[site]</span></span><br><span class="line"><span class="comment"># These two settings are necessary to save the assets to CF KV storage</span></span><br><span class="line"><span class="comment"># https://developers.cloudflare.com/workers/cli-wrangler/commands#kvkey</span></span><br><span class="line"><span class="comment"># https://developers.cloudflare.com/workers/cli-wrangler/configuration#site</span></span><br><span class="line"><span class="attr">bucket</span> = <span class="string">".universal"</span></span><br><span class="line"><span class="attr">entry-point</span> = <span class="string">"."</span></span><br><span class="line"></span><br><span class="line"><span class="section">[build]</span></span><br><span class="line"><span class="attr">command</span> = <span class="string">"pnpm build:cf-worker"</span></span><br><span class="line"><span class="attr">watch_dir</span> = <span class="string">"src"</span></span><br><span class="line"></span><br><span class="line"><span class="section">[build.upload]</span></span><br><span class="line"><span class="attr">format</span>=<span class="string">"service-worker"</span></span><br></pre></td></tr></table></figure>
<p>部署的话运行 <code>wrangler publish</code> 即可。</p>
<h2 id="总结与思考"><a class="markdownIt-Anchor" href="#总结与思考"></a> 总结与思考</h2>
<p>本文介绍的是 Speedy 的 SSR 实现，在实现 Speedy SSR 的过程中参考了 Vite、Next.js 和 Remix。其实业界的 SSR 实现总体思路都是基本上一致的，主要的点有：</p>
<ul>
<li>一份代码，两份产物，实现客户端和服务端复用</li>
<li>开发体验，API 设计简洁，可拓展性强，开发速度快</li>
<li>部署到不同的环境的支持</li>
<li>性能提升，最终的目标是提升页面的首屏性能，达到秒开的目的。</li>
</ul>
<p>Speedy 最终以失败而告终，去年已经逐渐不再维护了，主要还是 esbuild 的关注点和其他构建工具不一样，例如 HMR、拆包等就做的很不好；Rspack 成为了团队新推的构建工具，两者都借鉴了 Webpack 的插件体系，想做的东西也很类似，就是提升大家的开发效率，不过我没有参与过 Rspack 的开发，就不是很熟悉了。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ol>
<li><a href="https://github.com/upupming/speedy-ssr-examples" target="_blank" rel="noopener">https://github.com/upupming/speedy-ssr-examples</a></li>
<li><a href="http://www.ayqy.net/blog/diference-between-ssr-and-jsp-php/" target="_blank" rel="noopener">SSR与当年的JSP、PHP有什么区别？</a></li>
<li><a href="https://vitejs.dev/guide/ssr.html" target="_blank" rel="noopener">https://vitejs.dev/guide/ssr.html</a></li>
<li><a href="https://github.com/vitejs/vite/tree/main/packages/playground" target="_blank" rel="noopener">https://github.com/vitejs/vite/tree/main/packages/playground</a></li>
<li><a href="https://github.com/frandiox/vite-ssr" target="_blank" rel="noopener">https://github.com/frandiox/vite-ssr</a></li>
<li><a href="https://vitedge.js.org/" target="_blank" rel="noopener">https://vitedge.js.org/</a></li>
<li><a href="https://vercel.com/guides/using-express-with-vercel" target="_blank" rel="noopener">https://vercel.com/guides/using-express-with-vercel</a></li>
<li><a href="https://blog.cloudflare.com/serverless-rendering-with-cloudflare-workers/" target="_blank" rel="noopener">https://blog.cloudflare.com/serverless-rendering-with-cloudflare-workers/</a></li>
<li><a href="https://next-code-elimination.vercel.app/" target="_blank" rel="noopener">https://next-code-elimination.vercel.app/</a></li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">upupming</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://upupming.site/2023/05/21/bundler-ssr/">https://upupming.site/2023/05/21/bundler-ssr/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://upupming.site">upupming 的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/frontend/">frontend</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2024/02/25/ssr-introduction/"><i class="fa fa-chevron-left">  </i><span>服务端渲染的原理与实现</span></a></div><div class="next-post pull-right"><a href="/2022/03/25/typescript-getting-started/"><span>我眼中的 TypeScript（入门级别介绍）</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'wiHsGgANF4mLmK2Hiubzew03-gzGzoHsz',
  appKey:'Tk0WjoOhLD8ppTfyhdCbyeDT',
  placeholder:'Just go go',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(/img/background.png)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2024 By upupming</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>